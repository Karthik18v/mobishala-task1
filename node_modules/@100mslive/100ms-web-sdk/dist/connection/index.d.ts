import { HMSConnectionRole } from './model';
import { ISignal } from '../signal/ISignal';
import HMSTrack from '../media/tracks/HMSTrack';
export default abstract class HMSConnection {
    readonly role: HMSConnectionRole;
    protected readonly signal: ISignal;
    abstract readonly nativeConnection: RTCPeerConnection;
    /**
     * We keep a list of pending IceCandidates received
     * from the signalling server. When the peer-connection
     * is initialized we call [addIceCandidate] for each.
     *
     * WARN:
     *  - [HMSPublishConnection] keeps the complete list of candidates (for
     *      ice-connection failed/disconnect) forever.
     *  - [HMSSubscribeConnection] clears this list as soon as we call [addIceCandidate]
     */
    readonly candidates: RTCIceCandidateInit[];
    protected constructor(role: HMSConnectionRole, signal: ISignal);
    addTransceiver(track: MediaStreamTrack, init: RTCRtpTransceiverInit): RTCRtpTransceiver;
    createOffer(options?: RTCOfferOptions | undefined): Promise<RTCSessionDescriptionInit>;
    createAnswer(options?: RTCOfferOptions | undefined): Promise<RTCSessionDescriptionInit>;
    setLocalDescription(description: RTCSessionDescriptionInit): Promise<void>;
    setRemoteDescription(description: RTCSessionDescriptionInit): Promise<void>;
    addIceCandidate(candidate: RTCIceCandidateInit): Promise<void>;
    get remoteDescription(): RTCSessionDescription | null;
    getSenders(): Array<RTCRtpSender>;
    removeTrack(sender: RTCRtpSender): void;
    setMaxBitrate(maxBitrate: number, track: HMSTrack): Promise<void>;
    close(): Promise<void>;
}
