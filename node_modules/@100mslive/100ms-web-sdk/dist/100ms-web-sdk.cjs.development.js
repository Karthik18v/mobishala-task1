'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var uuid = require('uuid');

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var HMSAnalyticsLevel;

(function (HMSAnalyticsLevel) {
  HMSAnalyticsLevel[HMSAnalyticsLevel["OFF"] = 0] = "OFF";
  HMSAnalyticsLevel[HMSAnalyticsLevel["ERROR"] = 1] = "ERROR";
  HMSAnalyticsLevel[HMSAnalyticsLevel["INFO"] = 2] = "INFO";
  HMSAnalyticsLevel[HMSAnalyticsLevel["VERBOSE"] = 3] = "VERBOSE";
})(HMSAnalyticsLevel || (HMSAnalyticsLevel = {}));

var HMSLogLevel;

(function (HMSLogLevel) {
  HMSLogLevel[HMSLogLevel["VERBOSE"] = 0] = "VERBOSE";
  HMSLogLevel[HMSLogLevel["DEBUG"] = 1] = "DEBUG";
  HMSLogLevel[HMSLogLevel["INFO"] = 2] = "INFO";
  HMSLogLevel[HMSLogLevel["WARN"] = 3] = "WARN";
  HMSLogLevel[HMSLogLevel["ERROR"] = 4] = "ERROR";
  HMSLogLevel[HMSLogLevel["NONE"] = 5] = "NONE";
})(HMSLogLevel || (HMSLogLevel = {}));

var HMSLogger = /*#__PURE__*/function () {
  function HMSLogger() {}

  HMSLogger.v = function v(tag) {
    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    this.log.apply(this, [HMSLogLevel.VERBOSE, tag].concat(data));
  };

  HMSLogger.d = function d(tag) {
    for (var _len2 = arguments.length, data = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    this.log.apply(this, [HMSLogLevel.DEBUG, tag].concat(data));
  };

  HMSLogger.i = function i(tag) {
    for (var _len3 = arguments.length, data = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      data[_key3 - 1] = arguments[_key3];
    }

    this.log.apply(this, [HMSLogLevel.INFO, tag].concat(data));
  };

  HMSLogger.w = function w(tag) {
    for (var _len4 = arguments.length, data = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      data[_key4 - 1] = arguments[_key4];
    }

    this.log.apply(this, [HMSLogLevel.WARN, tag].concat(data));
  };

  HMSLogger.e = function e(tag) {
    for (var _len5 = arguments.length, data = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      data[_key5 - 1] = arguments[_key5];
    }

    this.log.apply(this, [HMSLogLevel.ERROR, tag].concat(data));
  };

  HMSLogger.log = function log(level, tag) {
    if (this.level.valueOf() > level.valueOf()) {
      return;
    }

    for (var _len6 = arguments.length, data = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
      data[_key6 - 2] = arguments[_key6];
    }

    switch (level) {
      case HMSLogLevel.VERBOSE:
        {
          var _console;

          (_console = console).log.apply(_console, [tag].concat(data));

          break;
        }

      case HMSLogLevel.DEBUG:
        {
          var _console2;

          (_console2 = console).debug.apply(_console2, [tag].concat(data));

          break;
        }

      case HMSLogLevel.INFO:
        {
          var _console3;

          (_console3 = console).info.apply(_console3, [tag].concat(data));

          break;
        }

      case HMSLogLevel.WARN:
        {
          var _console4;

          (_console4 = console).warn.apply(_console4, [tag].concat(data));

          break;
        }

      case HMSLogLevel.ERROR:
        {
          var _console5;

          (_console5 = console).error.apply(_console5, [tag].concat(data));

          break;
        }
    }
  };

  return HMSLogger;
}();
HMSLogger.level = HMSLogLevel.VERBOSE;

var TAG = 'HMSConnection';

var HMSConnection = /*#__PURE__*/function () {
  function HMSConnection(role, signal) {
    /**
     * We keep a list of pending IceCandidates received
     * from the signalling server. When the peer-connection
     * is initialized we call [addIceCandidate] for each.
     *
     * WARN:
     *  - [HMSPublishConnection] keeps the complete list of candidates (for
     *      ice-connection failed/disconnect) forever.
     *  - [HMSSubscribeConnection] clears this list as soon as we call [addIceCandidate]
     */
    this.candidates = new Array();
    this.role = role;
    this.signal = signal;
  }

  var _proto = HMSConnection.prototype;

  _proto.addTransceiver = function addTransceiver(track, init) {
    return this.nativeConnection.addTransceiver(track, init);
  };

  _proto.createOffer = /*#__PURE__*/function () {
    var _createOffer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(options) {
      var offer;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (options === void 0) {
                options = undefined;
              }

              _context.prev = 1;
              _context.next = 4;
              return this.nativeConnection.createOffer(options);

            case 4:
              offer = _context.sent;
              HMSLogger.d(TAG, "[role=" + this.role + "] createOffer offer=" + JSON.stringify(offer, null, 1));
              return _context.abrupt("return", offer);

            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](1);
              throw _context.t0;

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[1, 9]]);
    }));

    function createOffer(_x) {
      return _createOffer.apply(this, arguments);
    }

    return createOffer;
  }();

  _proto.createAnswer = /*#__PURE__*/function () {
    var _createAnswer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(options) {
      var answer;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (options === void 0) {
                options = undefined;
              }

              _context2.next = 3;
              return this.nativeConnection.createAnswer(options);

            case 3:
              answer = _context2.sent;
              HMSLogger.d(TAG, "[role=" + this.role + "] createAnswer answer=" + JSON.stringify(answer, null, 1));
              return _context2.abrupt("return", answer);

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function createAnswer(_x2) {
      return _createAnswer.apply(this, arguments);
    }

    return createAnswer;
  }();

  _proto.setLocalDescription = /*#__PURE__*/function () {
    var _setLocalDescription = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(description) {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              HMSLogger.d(TAG, "[role=" + this.role + "] setLocalDescription description=" + JSON.stringify(description, null, 1));
              _context3.next = 3;
              return this.nativeConnection.setLocalDescription(description);

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function setLocalDescription(_x3) {
      return _setLocalDescription.apply(this, arguments);
    }

    return setLocalDescription;
  }();

  _proto.setRemoteDescription = /*#__PURE__*/function () {
    var _setRemoteDescription = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(description) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              HMSLogger.d(TAG, "[role=" + this.role + "] setRemoteDescription description=" + JSON.stringify(description, null, 1));
              _context4.next = 4;
              return this.nativeConnection.setRemoteDescription(description);

            case 4:
              _context4.next = 9;
              break;

            case 6:
              _context4.prev = 6;
              _context4.t0 = _context4["catch"](0);
              throw _context4.t0;

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this, [[0, 6]]);
    }));

    function setRemoteDescription(_x4) {
      return _setRemoteDescription.apply(this, arguments);
    }

    return setRemoteDescription;
  }();

  _proto.addIceCandidate = /*#__PURE__*/function () {
    var _addIceCandidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(candidate) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              HMSLogger.d(TAG, "[role=" + this.role + "] addIceCandidate candidate=" + JSON.stringify(candidate, null, 1));
              _context5.next = 3;
              return this.nativeConnection.addIceCandidate(candidate);

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function addIceCandidate(_x5) {
      return _addIceCandidate.apply(this, arguments);
    }

    return addIceCandidate;
  }();

  _proto.getSenders = function getSenders() {
    return this.nativeConnection.getSenders();
  };

  _proto.removeTrack = function removeTrack(sender) {
    this.nativeConnection.removeTrack(sender);
  };

  _proto.setMaxBitrate = /*#__PURE__*/function () {
    var _setMaxBitrate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(maxBitrate, track) {
      var sender, params;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              sender = this.getSenders().find(function (s) {
                var _s$track;

                return (s == null ? void 0 : (_s$track = s.track) == null ? void 0 : _s$track.id) === track.trackId;
              });

              if (!sender) {
                _context6.next = 6;
                break;
              }

              params = sender.getParameters();
              params.encodings[0].maxBitrate = maxBitrate * 1000;
              _context6.next = 6;
              return sender.setParameters(params);

            case 6:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function setMaxBitrate(_x6, _x7) {
      return _setMaxBitrate.apply(this, arguments);
    }

    return setMaxBitrate;
  }();

  _proto.close = /*#__PURE__*/function () {
    var _close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7() {
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              this.nativeConnection.close();

            case 1:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function close() {
      return _close.apply(this, arguments);
    }

    return close;
  }();

  _createClass(HMSConnection, [{
    key: "remoteDescription",
    get: function get() {
      return this.nativeConnection.remoteDescription;
    }
  }]);

  return HMSConnection;
}();

var HMSConnectionRole;

(function (HMSConnectionRole) {
  HMSConnectionRole[HMSConnectionRole["Publish"] = 0] = "Publish";
  HMSConnectionRole[HMSConnectionRole["Subscribe"] = 1] = "Subscribe";
})(HMSConnectionRole || (HMSConnectionRole = {}));

var RENEGOTIATION_CALLBACK_ID = 'renegotiation-callback-id';
var API_DATA_CHANNEL = 'ion-sfu';

var TAG$1 = 'HMSPublishConnection';

var HMSPublishConnection = /*#__PURE__*/function (_HMSConnection) {
  _inheritsLoose(HMSPublishConnection, _HMSConnection);

  function HMSPublishConnection(signal, config, observer, transport) {
    var _this;

    _this = _HMSConnection.call(this, HMSConnectionRole.Publish, signal) || this;
    _this.observer = observer;
    _this.transport = transport;
    _this.nativeConnection = new RTCPeerConnection(config);

    _this.nativeConnection.createDataChannel(API_DATA_CHANNEL, {
      protocol: 'SCTP'
    });

    _this.nativeConnection.onicecandidate = function (_ref) {
      var candidate = _ref.candidate;

      if (candidate) {
        signal.trickle(_this.role, candidate);
      }
    };

    _this.nativeConnection.oniceconnectionstatechange = function () {
      _this.observer.onIceConnectionChange(_this.nativeConnection.iceConnectionState);
    };

    return _this;
  }

  var _proto = HMSPublishConnection.prototype;

  _proto.initAfterJoin = function initAfterJoin() {
    var _this2 = this;

    this.nativeConnection.onnegotiationneeded = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              HMSLogger.d(TAG$1, "onnegotiationneeded");
              _context.next = 3;
              return _this2.observer.onRenegotiationNeeded();

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
  };

  _proto.trackUpdate = function trackUpdate(track) {
    this.transport.trackUpdate(track);
  };

  return HMSPublishConnection;
}(HMSConnection);

/** @internal */
var HMSMediaStream = function HMSMediaStream(nativeStream) {
  this.tracks = new Array();
  this.nativeStream = nativeStream;
  this.id = nativeStream.id;
};

var HMSSimulcastLayer;

(function (HMSSimulcastLayer) {
  HMSSimulcastLayer["NONE"] = "none";
  HMSSimulcastLayer["LOW"] = "low";
  HMSSimulcastLayer["MEDIUM"] = "medium";
  HMSSimulcastLayer["HIGH"] = "high";
})(HMSSimulcastLayer || (HMSSimulcastLayer = {}));

/** @internal */

var HMSRemoteStream = /*#__PURE__*/function (_HMSMediaStream) {
  _inheritsLoose(HMSRemoteStream, _HMSMediaStream);

  function HMSRemoteStream(nativeStream, connection) {
    var _this;

    _this = _HMSMediaStream.call(this, nativeStream) || this;
    _this.audio = true;
    _this.video = HMSSimulcastLayer.HIGH;
    _this.frameRate = HMSSimulcastLayer.HIGH;
    _this.connection = connection;
    return _this;
  }

  var _proto = HMSRemoteStream.prototype;

  _proto.setAudio = /*#__PURE__*/function () {
    var _setAudio = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(enabled) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this.audio = enabled;
              _context.next = 3;
              return this.syncWithApiChannel();

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function setAudio(_x) {
      return _setAudio.apply(this, arguments);
    }

    return setAudio;
  }();

  _proto.setVideo = /*#__PURE__*/function () {
    var _setVideo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(layer) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              this.video = layer;
              _context2.next = 3;
              return this.syncWithApiChannel();

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function setVideo(_x2) {
      return _setVideo.apply(this, arguments);
    }

    return setVideo;
  }();

  _proto.syncWithApiChannel = /*#__PURE__*/function () {
    var _syncWithApiChannel = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      var _this$connection$apiC;

      var data;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              data = {
                streamId: this.nativeStream.id,
                video: this.video,
                audio: this.audio,
                framerate: this.frameRate
              };
              _context3.next = 3;
              return (_this$connection$apiC = this.connection.apiChannel) == null ? void 0 : _this$connection$apiC.send(JSON.stringify(data));

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function syncWithApiChannel() {
      return _syncWithApiChannel.apply(this, arguments);
    }

    return syncWithApiChannel;
  }();

  return HMSRemoteStream;
}(HMSMediaStream);

var HMSDataChannel = /*#__PURE__*/function () {
  function HMSDataChannel(nativeChannel, observer, metadata) {
    var _this = this;

    if (metadata === void 0) {
      metadata = '';
    }

    this.TAG = 'HMSDataChannel';
    this.msgQueue = [];
    this.nativeChannel = nativeChannel;
    this.observer = observer;
    this.metadata = metadata;

    nativeChannel.onmessage = function (e) {
      // HMSLogger.d(this.TAG, `[${this.metadata}] onMessage: label=${this.label}, message=${e.data}`);
      _this.observer.onMessage(e.data);
    };

    nativeChannel.onopen = function () {
      if (_this.msgQueue.length > 0) {
        HMSLogger.d('Found pending message queue, sending messages');

        _this.msgQueue.forEach(function (msg) {
          return _this.send(msg);
        });

        _this.msgQueue.length = 0;
      }
    };
  }

  var _proto = HMSDataChannel.prototype;

  _proto.send = /*#__PURE__*/function () {
    var _send = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(message) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (this.nativeChannel.readyState === 'open') {
                HMSLogger.d(this.TAG, "[" + this.metadata + "] Sending [size=" + message.length + "] message=" + message);
                this.nativeChannel.send(message);
              } else {
                HMSLogger.d(this.TAG, 'Connection is not open, queueing', message);
                this.msgQueue.push(message);
              }

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function send(_x) {
      return _send.apply(this, arguments);
    }

    return send;
  }();

  _proto.close = function close() {
    this.nativeChannel.close();
  };

  _createClass(HMSDataChannel, [{
    key: "id",
    get: function get() {
      return this.nativeChannel.id;
    }
  }, {
    key: "label",
    get: function get() {
      return this.nativeChannel.label;
    }
  }]);

  return HMSDataChannel;
}();

var HMSTrack = /*#__PURE__*/function () {
  function HMSTrack(stream, track, source) {
    this.stream = stream;
    this.nativeTrack = track;
    this.source = source;
  }

  var _proto = HMSTrack.prototype;

  _proto.getMediaTrackSettings = function getMediaTrackSettings() {
    return this.nativeTrack.getSettings();
  };

  _proto.setEnabled = /*#__PURE__*/function () {
    var _setEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(value) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this.nativeTrack.enabled = value;

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function setEnabled(_x) {
      return _setEnabled.apply(this, arguments);
    }

    return setEnabled;
  }();

  _createClass(HMSTrack, [{
    key: "enabled",
    get: function get() {
      return this.nativeTrack.enabled;
    }
  }, {
    key: "trackId",
    get: function get() {
      return this.nativeTrack.id;
    }
  }]);

  return HMSTrack;
}();

(function (HMSTrackType) {
  HMSTrackType["AUDIO"] = "audio";
  HMSTrackType["VIDEO"] = "video";
})(exports.HMSTrackType || (exports.HMSTrackType = {}));

var HMSAudioTrack = /*#__PURE__*/function (_HMSTrack) {
  _inheritsLoose(HMSAudioTrack, _HMSTrack);

  function HMSAudioTrack(stream, track, source) {
    var _this;

    _this = _HMSTrack.call(this, stream, track, source) || this;
    _this.type = exports.HMSTrackType.AUDIO;
    if (track.kind !== 'audio') throw new Error("Expected 'track' kind = 'audio'");
    return _this;
  }

  return HMSAudioTrack;
}(HMSTrack);

var HMSRemoteAudioTrack = /*#__PURE__*/function (_HMSAudioTrack) {
  _inheritsLoose(HMSRemoteAudioTrack, _HMSAudioTrack);

  function HMSRemoteAudioTrack() {
    return _HMSAudioTrack.apply(this, arguments) || this;
  }

  var _proto = HMSRemoteAudioTrack.prototype;

  _proto.setEnabled = /*#__PURE__*/function () {
    var _setEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(value) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(value === this.enabled)) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              _context.next = 4;
              return _HMSAudioTrack.prototype.setEnabled.call(this, value);

            case 4:
              _context.next = 6;
              return this.stream.setAudio(value);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function setEnabled(_x) {
      return _setEnabled.apply(this, arguments);
    }

    return setEnabled;
  }();

  return HMSRemoteAudioTrack;
}(HMSAudioTrack);

var HMSVideoTrack = /*#__PURE__*/function (_HMSTrack) {
  _inheritsLoose(HMSVideoTrack, _HMSTrack);

  function HMSVideoTrack(stream, track, source) {
    var _this;

    _this = _HMSTrack.call(this, stream, track, source) || this;
    _this.type = exports.HMSTrackType.VIDEO;
    if (track.kind !== 'video') throw new Error("Expected 'track' kind = 'video'");
    return _this;
  }

  var _proto = HMSVideoTrack.prototype;

  _proto.addSink = function addSink(videoElement) {
    videoElement.srcObject = new MediaStream([this.nativeTrack]);
  };

  _proto.removeSink = function removeSink(videoElement) {
    videoElement.srcObject = null;
  };

  return HMSVideoTrack;
}(HMSTrack);

var HMSRemoteVideoTrack = /*#__PURE__*/function (_HMSVideoTrack) {
  _inheritsLoose(HMSRemoteVideoTrack, _HMSVideoTrack);

  function HMSRemoteVideoTrack() {
    return _HMSVideoTrack.apply(this, arguments) || this;
  }

  var _proto = HMSRemoteVideoTrack.prototype;

  _proto.setEnabled = /*#__PURE__*/function () {
    var _setEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(value) {
      var layer;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(value === this.enabled)) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              _context.next = 4;
              return _HMSVideoTrack.prototype.setEnabled.call(this, value);

            case 4:
              layer = value ? HMSSimulcastLayer.HIGH : HMSSimulcastLayer.NONE;
              _context.next = 7;
              return this.preferLayer(layer);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function setEnabled(_x) {
      return _setEnabled.apply(this, arguments);
    }

    return setEnabled;
  }();

  _proto.preferLayer = /*#__PURE__*/function () {
    var _preferLayer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(layer) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.stream.setVideo(layer);

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function preferLayer(_x2) {
      return _preferLayer.apply(this, arguments);
    }

    return preferLayer;
  }();

  _proto.addSink = /*#__PURE__*/function () {
    var _addSink = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(videoElement) {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.preferLayer(HMSSimulcastLayer.HIGH);

            case 2:
              _HMSVideoTrack.prototype.addSink.call(this, videoElement);

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function addSink(_x3) {
      return _addSink.apply(this, arguments);
    }

    return addSink;
  }();

  _proto.removeSink = /*#__PURE__*/function () {
    var _removeSink = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(videoElement) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.preferLayer(HMSSimulcastLayer.NONE);

            case 2:
              _HMSVideoTrack.prototype.removeSink.call(this, videoElement);

            case 3:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function removeSink(_x4) {
      return _removeSink.apply(this, arguments);
    }

    return removeSink;
  }();

  return HMSRemoteVideoTrack;
}(HMSVideoTrack);

var HMSSubscribeConnection = /*#__PURE__*/function (_HMSConnection) {
  _inheritsLoose(HMSSubscribeConnection, _HMSConnection);

  function HMSSubscribeConnection(signal, config, observer) {
    var _this;

    _this = _HMSConnection.call(this, HMSConnectionRole.Subscribe, signal) || this;
    _this.remoteStreams = new Map();
    _this._apiChannel = null;
    _this.observer = observer;
    _this.nativeConnection = new RTCPeerConnection(config);

    _this.initNativeConnectionCallbacks();

    return _this;
  }

  var _proto = HMSSubscribeConnection.prototype;

  _proto.initNativeConnectionCallbacks = function initNativeConnectionCallbacks() {
    var _this2 = this;

    this.nativeConnection.oniceconnectionstatechange = function () {
      _this2.observer.onIceConnectionChange(_this2.nativeConnection.iceConnectionState);
    };

    this.nativeConnection.ondatachannel = function (e) {
      if (e.channel.label !== API_DATA_CHANNEL) {
        // TODO: this.observer.onDataChannel(e.channel);
        return;
      }

      _this2._apiChannel = new HMSDataChannel(e.channel, {
        onMessage: function onMessage(value) {
          _this2.observer.onApiChannelMessage(value);
        }
      }, "role=" + _this2.role);
    };

    this.nativeConnection.onicecandidate = function (e) {
      if (e.candidate !== null) {
        _this2.signal.trickle(_this2.role, e.candidate);
      }
    };

    this.nativeConnection.ontrack = function (e) {
      var stream = e.streams[0];

      if (!_this2.remoteStreams.has(stream.id)) {
        var _remote = new HMSRemoteStream(stream, _this2);

        _this2.remoteStreams.set(stream.id, _remote);

        stream.onremovetrack = function (e) {
          var toRemoveTrackIdx = _remote.tracks.findIndex(function (track) {
            return track.trackId === e.track.id;
          });

          if (toRemoveTrackIdx >= 0) {
            var toRemoveTrack = _remote.tracks[toRemoveTrackIdx];

            _this2.observer.onTrackRemove(toRemoveTrack);

            _remote.tracks.splice(toRemoveTrackIdx, 1); // If the length becomes 0 we assume that stream is removed entirely


            if (_remote.tracks.length === 0) {
              _this2.remoteStreams["delete"](stream.id);
            }
          }
        };
      }

      var remote = _this2.remoteStreams.get(stream.id);

      var TrackCls = e.track.kind === 'audio' ? HMSRemoteAudioTrack : HMSRemoteVideoTrack;
      var track = new TrackCls(remote, e.track);
      remote.tracks.push(track);

      _this2.observer.onTrackAdd(track);
    };
  };

  _proto.close = /*#__PURE__*/function () {
    var _close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var _this$apiChannel;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _HMSConnection.prototype.close.call(this);

            case 2:
              (_this$apiChannel = this.apiChannel) == null ? void 0 : _this$apiChannel.close();

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function close() {
      return _close.apply(this, arguments);
    }

    return close;
  }();

  _createClass(HMSSubscribeConnection, [{
    key: "apiChannel",
    get: function get() {
      // TODO: Wait for the channel to be open;
      return this._apiChannel;
    }
  }]);

  return HMSSubscribeConnection;
}(HMSConnection);

var TAG$2 = 'InitService';

var InitService = /*#__PURE__*/function () {
  function InitService() {}

  InitService.fetchInitConfig = /*#__PURE__*/function () {
    var _fetchInitConfig = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(token, initEndpoint, region) {
      var url, response;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (initEndpoint === void 0) {
                initEndpoint = 'https://qa-init.100ms.live/init';
              }

              if (region === void 0) {
                region = '';
              }

              HMSLogger.d(TAG$2, "fetchInitConfig: initEndpoint=" + initEndpoint + " token=" + token + " region=" + region);
              url = initEndpoint + "?token=" + token;

              if (region.length > 0) {
                url += "&region=" + region;
              } // @TODO: Add user-agent, handle error status codes


              _context.next = 7;
              return fetch(url);

            case 7:
              response = _context.sent;
              _context.next = 10;
              return response.json();

            case 10:
              return _context.abrupt("return", _context.sent);

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function fetchInitConfig(_x, _x2, _x3) {
      return _fetchInitConfig.apply(this, arguments);
    }

    return fetchInitConfig;
  }();

  return InitService;
}();

var HMSAction;

(function (HMSAction) {
  HMSAction[HMSAction["SwitchDevice"] = 0] = "SwitchDevice";
  HMSAction[HMSAction["GetLocalStream"] = 1] = "GetLocalStream";
  HMSAction[HMSAction["GetLocalScreen"] = 2] = "GetLocalScreen";
  HMSAction[HMSAction["GetLocalDevices"] = 3] = "GetLocalDevices";
  HMSAction[HMSAction["Join"] = 4] = "Join";
  HMSAction[HMSAction["Publish"] = 5] = "Publish";
  HMSAction[HMSAction["Subscribe"] = 6] = "Subscribe";
  HMSAction[HMSAction["Unsubscribe"] = 7] = "Unsubscribe";
  HMSAction[HMSAction["Unpublish"] = 8] = "Unpublish";
  HMSAction[HMSAction["Failure"] = 9] = "Failure";
  HMSAction[HMSAction["Leave"] = 10] = "Leave";
  HMSAction[HMSAction["None"] = 11] = "None";
})(HMSAction || (HMSAction = {}));

/*
 * HMSErrors.ts
 *
 * Created by codegen
 * Copyright © 2021 100ms. All rights reserved.
 */
var HMSErrors = {
  /* Connection Errors */
  // Generic error
  GenericConnect: {
    code: 1000,
    messageTemplate: "Something went wrong",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Auth token is missing
  MissingToken: {
    code: 1001,
    messageTemplate: "Auth token is missing",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Token is not in proper JWT format
  InvalidTokenFormat: {
    code: 1002,
    messageTemplate: "This auth token format is not supported",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Token is missing room id parameter
  TokenMissingRoomId: {
    code: 1003,
    messageTemplate: "Auth token is missing room id field",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // SDK cannot establish websocket connection
  NetworkUnavailable: {
    code: 1004,
    messageTemplate: "Could not connect. Please check your internet connection and try again",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Token is not authorised/expired
  TokenNotAuthorised: {
    code: 1005,
    messageTemplate: "Auth token is not valid",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Endpoint url is malformed
  InvalidEndpointUrl: {
    code: 1006,
    messageTemplate: "Endpoint URL is invalid",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Endpoint is not responding
  EndpointUnreachable: {
    code: 1007,
    messageTemplate: "Endpoint is not reachable",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Signalling websocket connection failed / RTC Peer connection failed
  ConnectionLost: {
    code: 1008,
    messageTemplate: "Connection to server is lost. {error_info}",
    requiresAction: false,
    requiresErrorInfo: true
  },

  /* Local Stream Errors */
  // Generic error
  GenericStream: {
    code: 2000,
    messageTemplate: "Something went wrong",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Both publish audio/video is off nothing to return
  NothingToReturn: {
    code: 2001,
    messageTemplate: "There is no media to return. Please select either video or audio or both",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Trying to change codec on the fly
  CodecChangeNotPermitted: {
    code: 2002,
    messageTemplate: "Codec can't be changed mid call",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Trying to change publish video/audio mid call
  PublishSettingsCantBeChanged: {
    code: 2003,
    messageTemplate: "Publish options can't be changed mid call",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // User denied permission to access capture device
  CantAccessCaptureDevice: {
    code: 2004,
    messageTemplate: "No permission to access capture device",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // WEB: Capture device is no longer available (usb cam is not connected)
  DeviceNotAvailable: {
    code: 2005,
    messageTemplate: "Capture device is no longer available",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // WEB: Capture device is in use by another application
  DeviceInUse: {
    code: 2006,
    messageTemplate: "Capture device is in use by another application",
    requiresAction: false,
    requiresErrorInfo: false
  },

  /* Room Join/Leave Errors */
  // Generic error
  GenericJoin: {
    code: 3000,
    messageTemplate: "Something went wrong",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Unknown room id
  UnkownRoom: {
    code: 3001,
    messageTemplate: "This room id is not recongnised.",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Already joined
  AlreadyJoined: {
    code: 3002,
    messageTemplate: "You have already joined this room.",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Max room participants reached
  RoomParticipantLimitReached: {
    code: 3004,
    messageTemplate: "You can't join this room because it is already full.",
    requiresAction: false,
    requiresErrorInfo: false
  },

  /* Room Actions Errors */
  // Generic error
  GenericAction: {
    code: 4100,
    messageTemplate: "[{action}]: Something went wrong",
    requiresAction: true,
    requiresErrorInfo: false
  },
  // Has not joined the room
  NotInTheRoom: {
    code: 4101,
    messageTemplate: "[{action}]: You need to join the room before you can publish.",
    requiresAction: true,
    requiresErrorInfo: false
  },
  // Malformed server response (i.e sdp missing)
  InvalidServerResponse: {
    code: 4102,
    messageTemplate: "[{action}]: Unknown server response. {error_info} ",
    requiresAction: true,
    requiresErrorInfo: true
  },
  // Failed to establish RTCPeerConnection
  PeerConnectionFailed: {
    code: 4103,
    messageTemplate: "[{action}]: Could not establish a peer connection. {error_info} ",
    requiresAction: true,
    requiresErrorInfo: true
  },
  // Can't unpublish a stream that is not published
  UnpublishCalledBeforePublish: {
    code: 4104,
    messageTemplate: "Can't unpublish a stream that is not published",
    requiresAction: false,
    requiresErrorInfo: false
  },

  /* Generic Errors */
  // Not connected
  NotConnected: {
    code: 5000,
    messageTemplate: "Client is not connected",
    requiresAction: false,
    requiresErrorInfo: false
  },
  // Generic signalling error. I.e server is returning error response to some command but the SDK doesn't know how to handle.
  Signalling: {
    code: 5001,
    messageTemplate: "Unknown signalling error: {action} {error_info} ",
    requiresAction: true,
    requiresErrorInfo: true
  },
  // Generic SDK error. Some unforseen exception happened.
  Unknown: {
    code: 5002,
    messageTemplate: "Unknown exception: {error_info}",
    requiresAction: false,
    requiresErrorInfo: true
  },
  // Webrtc stack not initialised yet
  NotReady: {
    code: 5003,
    messageTemplate: "WebRTC engine is not ready yet",
    requiresAction: false,
    requiresErrorInfo: false
  }
};

var HMSExceptionBuilder = /*#__PURE__*/function () {
  function HMSExceptionBuilder(codeMessage) {
    this._action = null;
    this._errorInfo = null;
    this.cm = codeMessage;
  }

  var _proto = HMSExceptionBuilder.prototype;

  _proto.action = function action(_action) {
    this._action = HMSAction[_action].toString();
    return this;
  };

  _proto.errorInfo = function errorInfo(_errorInfo) {
    this._errorInfo = _errorInfo;
    return this;
  };

  HMSExceptionBuilder.from = function from(code, message, requiresAction, requiresErrorInfo) {
    if (requiresAction === void 0) {
      requiresAction = false;
    }

    if (requiresErrorInfo === void 0) {
      requiresErrorInfo = false;
    }

    var cm = {
      code: code,
      messageTemplate: message,
      requiresAction: requiresAction,
      requiresErrorInfo: requiresErrorInfo
    };

    if (!message.includes('{action}') && requiresAction) {
      cm.messageTemplate = "[{action}] " + cm.messageTemplate;
    }

    if (!message.includes('{error_info}') && requiresAction) {
      cm.messageTemplate = cm.messageTemplate + ". {error_info}";
    }

    return new HMSExceptionBuilder(cm);
  };

  _proto.build = function build() {
    var _this$cm = this.cm,
        code = _this$cm.code,
        requiresAction = _this$cm.requiresAction,
        requiresErrorInfo = _this$cm.requiresErrorInfo;
    var hmsErrorEntry = Object.entries(HMSErrors).find(function (errorEntry) {
      return errorEntry[1].code === code;
    });
    var title = hmsErrorEntry && hmsErrorEntry[0] || '';
    var message = this.cm.messageTemplate;

    if (requiresAction && this._action === null) {
      throw Error(code + ": " + message + " requires action property");
    } else if (requiresAction) {
      message = message.replace('{action}', this._action);
    } else if (this._action !== null) {
      message = "[" + this._action + "] " + message;
    }

    if (requiresErrorInfo && this._errorInfo === null) {
      throw Error(code + ": " + message + " requires errorInfo property");
    } else if (requiresErrorInfo) {
      message = message.replace('{error_info}', this._errorInfo);
    } else if (this._errorInfo !== null) {
      message = message + ". " + this._errorInfo;
    }

    return new HMSException(this.cm.code, title, message);
  };

  return HMSExceptionBuilder;
}();

var HMSException = /*#__PURE__*/function (_Error) {
  _inheritsLoose(HMSException, _Error);

  function HMSException(code, title, message) {
    var _this;

    _this = _Error.call(this, message) || this;
    _this.title = ''; // Ref: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work

    Object.setPrototypeOf(_assertThisInitialized(_this), HMSException.prototype);
    _this.name = 'HMSException';
    _this.title = title;
    _this.code = code;
    return _this;
  }

  return HMSException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var JsonRpcSignal = /*#__PURE__*/function () {
  function JsonRpcSignal(observer) {
    this.TAG = '[ SIGNAL ]: ';
    /**
     * Sometimes before [join] is completed, there could be a lot of trickles
     * Sending [HMSTrickle]` before [join] web socket message leads to
     * error: [500] no rtc transport exists for this Peer
     *
     * We keep a list of pending trickles and send them immediately after [join]
     * is done.
     */

    this.isJoinCompleted = false;
    this.pendingTrickle = [];
    this.socket = null;
    this.callbacks = new Map();
    this.observer = observer;
  }

  var _proto = JsonRpcSignal.prototype;

  _proto.call = /*#__PURE__*/function () {
    var _call = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(method, params) {
      var _this = this;

      var id, message, response;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              id = uuid.v4();
              message = {
                method: method,
                params: params,
                id: id
              };
              this.socket.send(JSON.stringify(message));
              _context.next = 5;
              return new Promise(function (resolve, reject) {
                _this.callbacks.set(id, {
                  resolve: resolve,
                  reject: reject
                });
              });

            case 5:
              response = _context.sent;
              return _context.abrupt("return", JSON.parse(response));

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function call(_x, _x2) {
      return _call.apply(this, arguments);
    }

    return call;
  }();

  _proto.notify = function notify(method, params) {
    var message = {
      method: method,
      params: params
    };
    this.socket.send(JSON.stringify(message));
  };

  _proto.open = function open(uri) {
    var _this2 = this;

    return new Promise(function (resolve) {
      _this2.socket = new WebSocket(uri); // @DISCUSS: Inject WebSocket as a dependency so that it can be easier to mock and test

      var openHandler = function openHandler() {
        resolve();

        _this2.socket.removeEventListener('open', openHandler);
      };

      _this2.socket.addEventListener('open', openHandler);

      _this2.socket.addEventListener('close', function (e) {
        // https://stackoverflow.com/questions/18803971/websocket-onerror-how-to-read-error-description
        if (e.code !== 1000) {
          // 1000 code indicated `Normal Closure` [https://tools.ietf.org/html/rfc6455#section-7.4.1]
          var error = new HMSExceptionBuilder(HMSErrors.ConnectionLost).errorInfo(e.reason + " [" + e.code + "]").build();

          _this2.observer.onFailure(error);
        }
      });

      _this2.socket.addEventListener('message', function (event) {
        return _this2.onMessageHandler(event.data);
      });
    });
  };

  _proto.close = /*#__PURE__*/function () {
    var _close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      var _this3 = this;

      var p;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              p = new Promise(function (resolve) {
                _this3.socket.addEventListener('close', function () {
                  return resolve();
                });
              }); // For `1000` Refer: https://tools.ietf.org/html/rfc6455#section-7.4.1

              this.socket.close(1000, 'Normal Close');
              return _context2.abrupt("return", p);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function close() {
      return _close.apply(this, arguments);
    }

    return close;
  }();

  _proto.join = /*#__PURE__*/function () {
    var _join = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(name, data, offer, disableVidAutoSub) {
      var _this4 = this;

      var params, response;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              params = {
                name: name,
                disableVidAutoSub: disableVidAutoSub,
                data: data,
                offer: offer
              };
              _context3.next = 3;
              return this.call('join', params);

            case 3:
              response = _context3.sent;
              this.isJoinCompleted = true;
              this.pendingTrickle.forEach(function (_ref) {
                var target = _ref.target,
                    candidate = _ref.candidate;
                return _this4.trickle(target, candidate);
              });
              this.pendingTrickle.length = 0;
              HMSLogger.d(this.TAG, "join: response=" + JSON.stringify(response, null, 1));
              return _context3.abrupt("return", response);

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function join(_x3, _x4, _x5, _x6) {
      return _join.apply(this, arguments);
    }

    return join;
  }();

  _proto.trickle = function trickle(target, candidate) {
    if (this.isJoinCompleted) {
      this.notify('trickle', {
        target: target,
        candidate: candidate
      });
    } else {
      this.pendingTrickle.push({
        target: target,
        candidate: candidate
      });
    }
  };

  _proto.offer = /*#__PURE__*/function () {
    var _offer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(desc, tracks) {
      var response;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.call('offer', {
                desc: desc,
                tracks: Object.fromEntries(tracks)
              });

            case 2:
              response = _context4.sent;
              return _context4.abrupt("return", response);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function offer(_x7, _x8) {
      return _offer.apply(this, arguments);
    }

    return offer;
  }();

  _proto.answer = function answer(desc) {
    this.notify('answer', {
      desc: desc
    });
  };

  _proto.trackUpdate = function trackUpdate(tracks) {
    HMSLogger.d(this.TAG, 'Track Update: ', {
      tracks: Object.fromEntries(tracks)
    });
    this.notify('track-update', {
      version: '1.0',
      tracks: Object.fromEntries(tracks)
    });
  };

  _proto.broadcast = function broadcast(message) {
    // Refer https://www.notion.so/100ms/Biz-Client-Communication-V2-0e93bf0fcd0d46d49e96099d498112d8#b6dd01c8e258442fb50c11c87e4581fb
    this.notify('broadcast', {
      version: '1.0',
      info: message
    });
  };

  _proto.recordStart = function recordStart() {};

  _proto.recordEnd = function recordEnd() {};

  _proto.leave = function leave() {
    this.notify('leave', {
      version: '1.0'
    });
  };

  _proto.analytics = function analytics() {};

  _proto.onMessageHandler = function onMessageHandler(text) {
    var response = JSON.parse(text);

    if (response.hasOwnProperty('id')) {
      /** This is a response to [call] */
      var id = response.id;

      if (this.callbacks.has(id)) {
        var cb = this.callbacks.get(id);
        this.callbacks["delete"](id);

        if (response.result) {
          cb.resolve(JSON.stringify(response.result));
        } else {
          var error = response.error;
          var ex = HMSExceptionBuilder.from(error.code, error.message).build();
          cb.reject(ex);
        }
      } else {
        this.observer.onNotification(response);
      }
    } else if (response.hasOwnProperty('method')) {
      if (response.method === 'offer') {
        this.observer.onOffer(response.params);
      } else if (response.method === 'trickle') {
        this.observer.onTrickle(response.params);
      } else {
        this.observer.onNotification(response);
      }
    } else throw Error("WebSocket message has no 'method' or 'id' field, message=" + response);
  };

  return JsonRpcSignal;
}();

var HMSVideoCodec;

(function (HMSVideoCodec) {
  HMSVideoCodec["VP8"] = "vp8";
  HMSVideoCodec["VP9"] = "vp9";
  HMSVideoCodec["H264"] = "h264";
})(HMSVideoCodec || (HMSVideoCodec = {}));

var HMSAudioCodec;

(function (HMSAudioCodec) {
  HMSAudioCodec["OPUS"] = "opus";
})(HMSAudioCodec || (HMSAudioCodec = {}));

var HMSAudioTrackSettingsBuilder = /*#__PURE__*/function () {
  function HMSAudioTrackSettingsBuilder() {
    this._volume = 1.0;
    this._codec = HMSAudioCodec.OPUS;
    this._maxBitrate = 32000;
    this._deviceId = 'default';
    this._advanced = [// @ts-ignore
    {
      googEchoCancellation: {
        exact: true
      }
    }, // @ts-ignore
    {
      googExperimentalEchoCancellation: {
        exact: true
      }
    }, {
      autoGainControl: {
        exact: true
      }
    }, {
      noiseSuppression: {
        exact: true
      }
    }, // @ts-ignore
    {
      googHighpassFilter: {
        exact: true
      }
    }, // @ts-ignore
    {
      googAudioMirroring: {
        exact: true
      }
    }];
  }

  var _proto = HMSAudioTrackSettingsBuilder.prototype;

  _proto.volume = function volume(_volume) {
    if (!(0.0 <= _volume && _volume <= 1.0)) throw Error('volume can only be in range [0.0, 1.0]');
    this._volume = _volume;
    return this;
  };

  _proto.codec = function codec(_codec) {
    this._codec = _codec;
    return this;
  };

  _proto.maxBitrate = function maxBitrate(_maxBitrate) {
    if (_maxBitrate <= 0) throw Error('maxBitrate should be >= 1');
    this._maxBitrate = _maxBitrate;
    return this;
  };

  _proto.deviceId = function deviceId(_deviceId) {
    // TODO: Validate if device-id is OK
    this._deviceId = _deviceId;
    return this;
  };

  _proto.advanced = function advanced(_advanced) {
    this._advanced = _advanced;
    return this;
  };

  _proto.build = function build() {
    return new HMSAudioTrackSettings(this._volume, this._codec, this._maxBitrate, this._deviceId, this._advanced);
  };

  return HMSAudioTrackSettingsBuilder;
}();

var HMSAudioTrackSettings = /*#__PURE__*/function () {
  function HMSAudioTrackSettings(volume, codec, maxBitrate, deviceId, advanced) {
    this.volume = volume;
    this.codec = codec;
    this.maxBitrate = maxBitrate;
    this.deviceId = deviceId;
    this.advanced = advanced;
  }

  var _proto2 = HMSAudioTrackSettings.prototype;

  _proto2.toConstraints = function toConstraints() {
    return {
      deviceId: this.deviceId,
      advanced: this.advanced
    };
  };

  return HMSAudioTrackSettings;
}();

var TAG$3 = 'HMSErrorFactory';
function BuildGetMediaError(err, action) {
  HMSLogger.e(TAG$3, "getLocalScreen", err);
  var message = err.message.toLowerCase();

  switch (err.name) {
    case 'OverconstrainedError':
      return new HMSExceptionBuilder(HMSErrors.Unknown).action(action).errorInfo(err.message).build();

    case 'NotAllowedError':
      return new HMSExceptionBuilder(HMSErrors.CantAccessCaptureDevice).action(action).errorInfo(err.message).build();

    case 'NotFoundError':
      return new HMSExceptionBuilder(HMSErrors.DeviceNotAvailable).action(action).errorInfo(err.message).build();

    case 'NotReadableError':
      return new HMSExceptionBuilder(HMSErrors.DeviceInUse).action(action).errorInfo(err.message).build();

    case 'TypeError':
      return new HMSExceptionBuilder(HMSErrors.NothingToReturn).action(action).errorInfo(err.message).build();

    default:
      if (message.includes('device not found')) {
        return new HMSExceptionBuilder(HMSErrors.DeviceNotAvailable).action(action).errorInfo(err.message).build();
      } else if (message.includes('permission denied')) {
        return new HMSExceptionBuilder(HMSErrors.CantAccessCaptureDevice).action(action).errorInfo(err.message).build();
      } else {
        return new HMSExceptionBuilder(HMSErrors.Unknown).action(action).errorInfo(err.message).build();
      }

  }
}

function getAudioTrack(_x) {
  return _getAudioTrack.apply(this, arguments);
}

function _getAudioTrack() {
  _getAudioTrack = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(settings) {
    var stream;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return navigator.mediaDevices.getUserMedia({
              audio: settings.toConstraints()
            });

          case 3:
            stream = _context.sent;
            return _context.abrupt("return", stream.getAudioTracks()[0]);

          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            throw BuildGetMediaError(_context.t0, HMSAction.SwitchDevice);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 7]]);
  }));
  return _getAudioTrack.apply(this, arguments);
}

function getVideoTrack(_x2) {
  return _getVideoTrack.apply(this, arguments);
} // the dimensions of the passed in track are used to create the empty video track

function _getVideoTrack() {
  _getVideoTrack = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(settings) {
    var stream;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return navigator.mediaDevices.getUserMedia({
              video: settings.toConstraints()
            });

          case 3:
            stream = _context2.sent;
            return _context2.abrupt("return", stream.getVideoTracks()[0]);

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](0);
            throw BuildGetMediaError(_context2.t0, HMSAction.SwitchDevice);

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 7]]);
  }));
  return _getVideoTrack.apply(this, arguments);
}

function getEmptyVideoTrack(prevTrack) {
  var _prevTrack$getSetting, _prevTrack$getSetting2, _canvas$getContext;

  var width = (prevTrack == null ? void 0 : (_prevTrack$getSetting = prevTrack.getSettings()) == null ? void 0 : _prevTrack$getSetting.width) || 640;
  var height = (prevTrack == null ? void 0 : (_prevTrack$getSetting2 = prevTrack.getSettings()) == null ? void 0 : _prevTrack$getSetting2.height) || 360;
  var canvas = Object.assign(document.createElement('canvas'), {
    width: width,
    height: height
  });
  (_canvas$getContext = canvas.getContext('2d')) == null ? void 0 : _canvas$getContext.fillRect(0, 0, width, height);
  var stream = canvas.captureStream();
  var emptyTrack = stream.getVideoTracks()[0];
  emptyTrack.enabled = false;
  return emptyTrack;
}

function generateHasPropertyChanged(newSettings, oldSettings) {
  return function hasChanged(prop) {
    return prop in newSettings && newSettings[prop] !== oldSettings[prop];
  };
}

var HMSLocalAudioTrack = /*#__PURE__*/function (_HMSAudioTrack) {
  _inheritsLoose(HMSLocalAudioTrack, _HMSAudioTrack);

  function HMSLocalAudioTrack(stream, track, settings, source) {
    var _this;

    _this = _HMSAudioTrack.call(this, stream, track, source) || this;
    stream.tracks.push(_assertThisInitialized(_this));
    _this.settings = settings;
    return _this;
  }

  var _proto = HMSLocalAudioTrack.prototype;

  _proto.replaceTrackWith = /*#__PURE__*/function () {
    var _replaceTrackWith = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(settings) {
      var prevTrack, withTrack;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              prevTrack = this.nativeTrack;
              _context.next = 3;
              return getAudioTrack(settings);

            case 3:
              withTrack = _context.sent;
              _context.next = 6;
              return this.stream.replaceTrack(this, withTrack);

            case 6:
              prevTrack == null ? void 0 : prevTrack.stop();

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function replaceTrackWith(_x) {
      return _replaceTrackWith.apply(this, arguments);
    }

    return replaceTrackWith;
  }();

  _proto.setEnabled = /*#__PURE__*/function () {
    var _setEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(value) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(value === this.enabled)) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return");

            case 2:
              _context2.next = 4;
              return _HMSAudioTrack.prototype.setEnabled.call(this, value);

            case 4:
              this.stream.trackUpdate(this);

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function setEnabled(_x2) {
      return _setEnabled.apply(this, arguments);
    }

    return setEnabled;
  }();

  _proto.setSettings = /*#__PURE__*/function () {
    var _setSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(settings) {
      var _this$settings$settin, volume, codec, maxBitrate, deviceId, advanced, newSettings, stream, hasPropertyChanged;

      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _this$settings$settin = _extends({}, this.settings, settings), volume = _this$settings$settin.volume, codec = _this$settings$settin.codec, maxBitrate = _this$settings$settin.maxBitrate, deviceId = _this$settings$settin.deviceId, advanced = _this$settings$settin.advanced;
              newSettings = new HMSAudioTrackSettings(volume, codec, maxBitrate, deviceId, advanced);
              stream = this.stream;
              hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);

              if (!hasPropertyChanged('deviceId')) {
                _context3.next = 7;
                break;
              }

              _context3.next = 7;
              return this.replaceTrackWith(newSettings);

            case 7:
              if (!hasPropertyChanged('maxBitrate')) {
                _context3.next = 10;
                break;
              }

              _context3.next = 10;
              return stream.setMaxBitrate(newSettings.maxBitrate, this);

            case 10:
              if (!hasPropertyChanged('advanced')) {
                _context3.next = 13;
                break;
              }

              _context3.next = 13;
              return this.nativeTrack.applyConstraints(newSettings.toConstraints());

            case 13:
              this.settings = newSettings;

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function setSettings(_x3) {
      return _setSettings.apply(this, arguments);
    }

    return setSettings;
  }();

  return HMSLocalAudioTrack;
}(HMSAudioTrack);

var HMSVideoTrackSettingsBuilder = /*#__PURE__*/function () {
  function HMSVideoTrackSettingsBuilder() {
    this._width = 320;
    this._height = 180;
    this._codec = HMSVideoCodec.VP8;
    this._maxFramerate = 30;
    this._maxBitrate = 150000;
    this._deviceId = 'default';
    this._advanced = [];
  }

  var _proto = HMSVideoTrackSettingsBuilder.prototype;

  _proto.setWidth = function setWidth(width) {
    this._width = width;
    return this;
  };

  _proto.setHeight = function setHeight(height) {
    this._height = height;
    return this;
  };

  _proto.codec = function codec(_codec) {
    this._codec = _codec;
    return this;
  };

  _proto.maxFramerate = function maxFramerate(_maxFramerate) {
    if (_maxFramerate <= 0) throw Error('maxFramerate should be >= 1');
    this._maxFramerate = _maxFramerate;
    return this;
  };

  _proto.maxBitrate = function maxBitrate(_maxBitrate) {
    if (_maxBitrate <= 0) throw Error('maxBitrate should be >= 1');
    this._maxBitrate = _maxBitrate;
    return this;
  };

  _proto.deviceId = function deviceId(_deviceId) {
    // TODO: Validate if device-id is OK
    this._deviceId = _deviceId;
    return this;
  };

  _proto.advanced = function advanced(_advanced) {
    this._advanced = _advanced;
    return this;
  };

  _proto.build = function build() {
    return new HMSVideoTrackSettings(this._width, this._height, this._codec, this._maxFramerate, this._maxBitrate, this._deviceId, this._advanced);
  };

  return HMSVideoTrackSettingsBuilder;
}();

var HMSVideoTrackSettings = /*#__PURE__*/function () {
  function HMSVideoTrackSettings(width, height, codec, maxFramerate, maxBitrate, deviceId, advanced) {
    this.width = width;
    this.height = height;
    this.codec = codec;
    this.maxFramerate = maxFramerate;
    this.maxBitrate = maxBitrate;
    this.deviceId = deviceId;
    this.advanced = advanced;
  }

  var _proto2 = HMSVideoTrackSettings.prototype;

  _proto2.toConstraints = function toConstraints() {
    return {
      width: this.width,
      height: this.height,
      frameRate: this.maxFramerate,
      deviceId: this.deviceId
    };
  };

  return HMSVideoTrackSettings;
}();

function generateHasPropertyChanged$1(newSettings, oldSettings) {
  return function hasChanged(prop) {
    return prop in newSettings && newSettings[prop] !== oldSettings[prop];
  };
}

var HMSLocalVideoTrack = /*#__PURE__*/function (_HMSVideoTrack) {
  _inheritsLoose(HMSLocalVideoTrack, _HMSVideoTrack);

  function HMSLocalVideoTrack(stream, track, settings, source) {
    var _this;

    _this = _HMSVideoTrack.call(this, stream, track, source) || this;
    stream.tracks.push(_assertThisInitialized(_this));
    _this.settings = settings;
    return _this;
  }

  var _proto = HMSLocalVideoTrack.prototype;

  _proto.replaceTrackWith = /*#__PURE__*/function () {
    var _replaceTrackWith = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(settings) {
      var prevTrack, withTrack;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              prevTrack = this.nativeTrack;
              _context.next = 3;
              return getVideoTrack(settings);

            case 3:
              withTrack = _context.sent;
              _context.next = 6;
              return this.stream.replaceTrack(this, withTrack);

            case 6:
              prevTrack == null ? void 0 : prevTrack.stop();

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function replaceTrackWith(_x) {
      return _replaceTrackWith.apply(this, arguments);
    }

    return replaceTrackWith;
  }();

  _proto.replaceTrackWithBlank = /*#__PURE__*/function () {
    var _replaceTrackWithBlank = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      var prevTrack, withTrack;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              prevTrack = this.nativeTrack;
              withTrack = getEmptyVideoTrack(prevTrack);
              _context2.next = 4;
              return this.stream.replaceTrack(this, withTrack);

            case 4:
              prevTrack == null ? void 0 : prevTrack.stop();

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function replaceTrackWithBlank() {
      return _replaceTrackWithBlank.apply(this, arguments);
    }

    return replaceTrackWithBlank;
  }();

  _proto.setEnabled = /*#__PURE__*/function () {
    var _setEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(value) {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(value === this.enabled)) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return");

            case 2:
              _context3.next = 4;
              return _HMSVideoTrack.prototype.setEnabled.call(this, value);

            case 4:
              this.stream.trackUpdate(this);

              if (!value) {
                _context3.next = 10;
                break;
              }

              _context3.next = 8;
              return this.replaceTrackWith(this.settings);

            case 8:
              _context3.next = 12;
              break;

            case 10:
              _context3.next = 12;
              return this.replaceTrackWithBlank();

            case 12:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function setEnabled(_x2) {
      return _setEnabled.apply(this, arguments);
    }

    return setEnabled;
  }();

  _proto.setSettings = /*#__PURE__*/function () {
    var _setSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(settings) {
      var _this$settings$settin, width, height, codec, maxFramerate, maxBitrate, deviceId, advanced, newSettings, stream, hasPropertyChanged;

      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _this$settings$settin = _extends({}, this.settings, settings), width = _this$settings$settin.width, height = _this$settings$settin.height, codec = _this$settings$settin.codec, maxFramerate = _this$settings$settin.maxFramerate, maxBitrate = _this$settings$settin.maxBitrate, deviceId = _this$settings$settin.deviceId, advanced = _this$settings$settin.advanced;
              newSettings = new HMSVideoTrackSettings(width, height, codec, maxFramerate, maxBitrate, deviceId, advanced);
              stream = this.stream;
              hasPropertyChanged = generateHasPropertyChanged$1(settings, this.settings);

              if (!hasPropertyChanged('deviceId')) {
                _context4.next = 7;
                break;
              }

              _context4.next = 7;
              return this.replaceTrackWith(newSettings);

            case 7:
              if (!hasPropertyChanged('maxBitrate')) {
                _context4.next = 10;
                break;
              }

              _context4.next = 10;
              return stream.setMaxBitrate(newSettings.maxBitrate, this);

            case 10:
              if (!(hasPropertyChanged('width') || hasPropertyChanged('height') || hasPropertyChanged('advanced'))) {
                _context4.next = 13;
                break;
              }

              _context4.next = 13;
              return this.nativeTrack.applyConstraints(newSettings.toConstraints());

            case 13:
              this.settings = newSettings;

            case 14:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function setSettings(_x3) {
      return _setSettings.apply(this, arguments);
    }

    return setSettings;
  }();

  return HMSLocalVideoTrack;
}(HMSVideoTrack);

var TAG$4 = 'HMSLocalStream';
/** @internal */

var HMSLocalStream = /*#__PURE__*/function (_HMSMediaStream) {
  _inheritsLoose(HMSLocalStream, _HMSMediaStream);

  function HMSLocalStream() {
    var _this;

    _this = _HMSMediaStream.apply(this, arguments) || this;
    /** Connection set when publish is called for the first track */

    _this.connection = null;
    return _this;
  }

  var _proto = HMSLocalStream.prototype;

  _proto.setConnection = function setConnection(connection) {
    this.connection = connection;
  };

  HMSLocalStream.getLocalScreen = /*#__PURE__*/function () {
    var _getLocalScreen = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(settings) {
      var constraints, stream, local, nativeTrack, track;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              constraints = {
                video: settings.toConstraints(),
                audio: false
              };
              _context.prev = 1;
              _context.next = 4;
              return navigator.mediaDevices.getDisplayMedia(constraints);

            case 4:
              stream = _context.sent;
              _context.next = 10;
              break;

            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](1);
              throw BuildGetMediaError(_context.t0, HMSAction.GetLocalScreen);

            case 10:
              local = new HMSLocalStream(stream);
              nativeTrack = stream.getVideoTracks()[0];
              track = new HMSLocalVideoTrack(local, nativeTrack, settings, 'screen');
              HMSLogger.v(TAG$4, 'getLocalScreen', track);
              return _context.abrupt("return", track);

            case 15:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[1, 7]]);
    }));

    function getLocalScreen(_x) {
      return _getLocalScreen.apply(this, arguments);
    }

    return getLocalScreen;
  }();

  HMSLocalStream.getLocalTracks = /*#__PURE__*/function () {
    var _getLocalTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(settings) {
      var stream, local, tracks, nativeTrack, track, _nativeTrack, _track;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return navigator.mediaDevices.getUserMedia({
                audio: settings.audio != null ? settings.audio.toConstraints() : false,
                video: settings.video != null ? settings.video.toConstraints() : false
              });

            case 3:
              stream = _context2.sent;
              _context2.next = 9;
              break;

            case 6:
              _context2.prev = 6;
              _context2.t0 = _context2["catch"](0);
              throw BuildGetMediaError(_context2.t0, HMSAction.GetLocalScreen);

            case 9:
              local = new HMSLocalStream(stream);
              tracks = [];

              if (settings.audio != null) {
                nativeTrack = stream.getAudioTracks()[0];
                track = new HMSLocalAudioTrack(local, nativeTrack, settings.audio, 'regular');
                tracks.push(track);
              }

              if (settings.video != null) {
                _nativeTrack = stream.getVideoTracks()[0];
                _track = new HMSLocalVideoTrack(local, _nativeTrack, settings.video, 'regular');
                tracks.push(_track);
              }

              HMSLogger.v(TAG$4, 'getLocalTracks', tracks);
              return _context2.abrupt("return", tracks);

            case 15:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[0, 6]]);
    }));

    function getLocalTracks(_x2) {
      return _getLocalTracks.apply(this, arguments);
    }

    return getLocalTracks;
  }();

  _proto.addTransceiver = function addTransceiver(track) {
    // TODO: Add support for simulcast
    var transceiver = this.connection.addTransceiver(track.nativeTrack, {
      streams: [this.nativeStream],
      direction: 'sendonly',
      sendEncodings: undefined
    });
    this.setPreferredCodec(transceiver, track.nativeTrack.kind);
    return transceiver;
  };

  _proto.setMaxBitrate = /*#__PURE__*/function () {
    var _setMaxBitrate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(maxBitrate, track) {
      var _this$connection;

      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return (_this$connection = this.connection) == null ? void 0 : _this$connection.setMaxBitrate(maxBitrate, track);

            case 2:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function setMaxBitrate(_x3, _x4) {
      return _setMaxBitrate.apply(this, arguments);
    }

    return setMaxBitrate;
  }() // @ts-ignore
  ;

  _proto.setPreferredCodec = function setPreferredCodec(transceiver, kind) {// TODO: Some browsers don't support setCodecPreferences, resort to SDPMunging?
  };

  _proto.replaceTrack = /*#__PURE__*/function () {
    var _replaceTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(track, withTrack) {
      var sender;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              sender = this.connection.getSenders().find(function (sender) {
                return sender.track && sender.track.id === track.trackId;
              });

              if (!(sender === undefined)) {
                _context4.next = 3;
                break;
              }

              throw Error("No sender found for trackId=" + track.trackId);

            case 3:
              this.nativeStream.addTrack(withTrack);
              this.nativeStream.removeTrack(track.nativeTrack);
              sender.track.stop(); // If the track is already stopped, this does not throw any error. 😉

              _context4.next = 8;
              return sender.replaceTrack(withTrack);

            case 8:
              track.nativeTrack = withTrack;

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function replaceTrack(_x5, _x6) {
      return _replaceTrack.apply(this, arguments);
    }

    return replaceTrack;
  }();

  _proto.removeSender = function removeSender(track) {
    var _this2 = this;

    var removedSenderCount = 0;
    this.connection.getSenders().forEach(function (sender) {
      if (sender.track && sender.track.id === track.trackId) {
        _this2.connection.removeTrack(sender);

        removedSenderCount += 1; // Remove the local reference as well

        var toRemoveLocalTrackIdx = _this2.tracks.indexOf(track);

        if (toRemoveLocalTrackIdx !== -1) {
          _this2.tracks.splice(toRemoveLocalTrackIdx, 1);
        } else throw Error("Cannot find " + track + " in locally stored tracks");
      }
    });

    if (removedSenderCount !== 1) {
      throw Error("Removed " + removedSenderCount + " sender's, expected to remove 1");
    }
  };

  _proto.trackUpdate = function trackUpdate(track) {
    var _this$connection2;

    (_this$connection2 = this.connection) == null ? void 0 : _this$connection2.trackUpdate(track);
  };

  return HMSLocalStream;
}(HMSMediaStream);

var HMSNotificationMethod;

(function (HMSNotificationMethod) {
  HMSNotificationMethod[HMSNotificationMethod["PEER_JOIN"] = 0] = "PEER_JOIN";
  HMSNotificationMethod[HMSNotificationMethod["PEER_LEAVE"] = 1] = "PEER_LEAVE";
  HMSNotificationMethod[HMSNotificationMethod["PEER_LIST"] = 2] = "PEER_LIST";
  HMSNotificationMethod[HMSNotificationMethod["ACTIVE_SPEAKERS"] = 3] = "ACTIVE_SPEAKERS";
  HMSNotificationMethod[HMSNotificationMethod["BROADCAST"] = 4] = "BROADCAST";
  HMSNotificationMethod[HMSNotificationMethod["ROLE_CHANGE"] = 5] = "ROLE_CHANGE";
  HMSNotificationMethod[HMSNotificationMethod["TRACK_METADATA_ADD"] = 6] = "TRACK_METADATA_ADD";
  HMSNotificationMethod[HMSNotificationMethod["TRACK_UPDATE"] = 7] = "TRACK_UPDATE";
  HMSNotificationMethod[HMSNotificationMethod["UNSUPPORTED"] = 8] = "UNSUPPORTED";
})(HMSNotificationMethod || (HMSNotificationMethod = {}));

var getNotificationMethod = function getNotificationMethod(method) {
  switch (method) {
    case 'on-peer-join':
      return HMSNotificationMethod.PEER_JOIN;

    case 'on-peer-leave':
      return HMSNotificationMethod.PEER_LEAVE;

    case 'peer-list':
      return HMSNotificationMethod.PEER_LIST;

    case 'on-track-add':
      return HMSNotificationMethod.TRACK_METADATA_ADD;

    case 'on-track-update':
      return HMSNotificationMethod.TRACK_UPDATE;

    case 'active-speakers':
      return HMSNotificationMethod.ACTIVE_SPEAKERS;

    case 'on-broadcast':
      return HMSNotificationMethod.BROADCAST;

    case 'on-role-change':
      return HMSNotificationMethod.ROLE_CHANGE;

    default:
      HMSLogger.d("method not supported - " + method);
      return HMSNotificationMethod.UNSUPPORTED;
  }
};

// String enum to pass type as string for identification on receiver's end.
var HMSMessageType;

(function (HMSMessageType) {
  HMSMessageType["CHAT"] = "chat";
})(HMSMessageType || (HMSMessageType = {}));

var getMessageType = function getMessageType(type) {
  // Default type is CHAT
  if (!type) {
    return HMSMessageType.CHAT;
  }

  switch (type) {
    case 'chat':
      return HMSMessageType.CHAT;

    default:
      throw Error("Unsupported message type=" + type + " received");
  }
};

var Message = function Message(_ref) {
  var sender = _ref.sender,
      message = _ref.message,
      type = _ref.type,
      receiver = _ref.receiver,
      time = _ref.time;
  this.receiver = '';
  this.sender = sender;
  this.message = message;
  this.type = getMessageType(type);

  if (receiver) {
    this.receiver = receiver;
  } // If time is available, creating Message object for a received message.


  if (time && time instanceof Date) {
    this.time = time;
  } else if (time && typeof time == 'string') {
    // If a received message has time as string(when using JSON.stringify), convert and store as Date object.
    this.time = new Date(time);
  } else {
    this.time = new Date();
  }
};

var Speaker = function Speaker(peerId, trackId, audioLevel) {
  this.audioLevel = 0;
  this.peerId = peerId;
  this.trackId = trackId;
  this.audioLevel = audioLevel;
};
var SpeakerList = function SpeakerList(speakerList) {
  this.speakers = [];

  if (speakerList && speakerList.length > 0) {
    this.speakers = speakerList.map(function (speaker) {
      return new Speaker(speaker.peer_id, speaker.track_id, speaker.level);
    });
  }
};

var TrackState = function TrackState(track) {
  this.type = track.type;
  this.source = track.source || 'regular';
  this.description = '';

  if (track instanceof HMSTrack) {
    this.mute = !track.enabled;
    this.track_id = track.trackId;
    this.stream_id = track.stream.id;
  } else {
    this.mute = track.mute;
    this.track_id = track.track_id;
    this.stream_id = track.stream_id;
  }
};
var Peer = function Peer(params) {
  this.tracks = [];
  this.peerId = params.peer_id;
  this.info = {
    name: params.info.name,
    data: params.info.data,
    userId: params.info.user_id
  };
  this.role = params.role;
  this.tracks = Object.values(params.tracks || {});
};
var PeerList = function PeerList(params) {
  this.peers = Object.values(params.peers).map(function (peer) {
    return new Peer(peer);
  });
};
var getNotification = function getNotification(method, params) {
  switch (method) {
    case HMSNotificationMethod.PEER_JOIN:
      return new Peer(params);

    case HMSNotificationMethod.PEER_LEAVE:
      return new Peer(params);

    case HMSNotificationMethod.PEER_LIST:
      return new PeerList(params);

    case HMSNotificationMethod.BROADCAST:
      return new Message(params.info);

    case HMSNotificationMethod.ACTIVE_SPEAKERS:
      return new SpeakerList(params['speaker-list']);

    case HMSNotificationMethod.ROLE_CHANGE:
      return params;

    case HMSNotificationMethod.TRACK_METADATA_ADD:
    case HMSNotificationMethod.TRACK_UPDATE:
      {
        return params;
      }

    default:
      HMSLogger.d("method not implemented " + method);
      return params;
  }
};

var TransportState;

(function (TransportState) {
  TransportState[TransportState["Joined"] = 0] = "Joined";
  TransportState[TransportState["Disconnected"] = 1] = "Disconnected";
  TransportState[TransportState["Failed"] = 2] = "Failed";
  TransportState[TransportState["Reconnecting"] = 3] = "Reconnecting";
})(TransportState || (TransportState = {}));

var TAG$5 = '[HMSTransport]:';

var HMSTransport = /*#__PURE__*/function () {
  function HMSTransport(observer) {
    var _this = this;

    this.state = TransportState.Disconnected;
    this.tracks = new Map();
    this.publishConnection = null;
    this.subscribeConnection = null;
    /**
     * Map of callbacks used to wait for an event to fire.
     * Used here for:
     *  1. publish/unpublish waits for [IPublishConnectionObserver.onRenegotiationNeeded] to complete
     */

    this.callbacks = new Map();
    this.signalObserver = {
      onOffer: function () {
        var _onOffer = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(jsep) {
          var _iterator, _step, candidate, answer;

          return runtime_1.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this.subscribeConnection.setRemoteDescription(jsep);

                case 2:
                  _iterator = _createForOfIteratorHelperLoose(_this.subscribeConnection.candidates);

                case 3:
                  if ((_step = _iterator()).done) {
                    _context.next = 9;
                    break;
                  }

                  candidate = _step.value;
                  _context.next = 7;
                  return _this.subscribeConnection.addIceCandidate(candidate);

                case 7:
                  _context.next = 3;
                  break;

                case 9:
                  _this.subscribeConnection.candidates.length = 0;
                  _context.next = 12;
                  return _this.subscribeConnection.createAnswer();

                case 12:
                  answer = _context.sent;
                  _context.next = 15;
                  return _this.subscribeConnection.setLocalDescription(answer);

                case 15:
                  _this.signal.answer(answer);

                case 16:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function onOffer(_x) {
          return _onOffer.apply(this, arguments);
        }

        return onOffer;
      }(),
      onTrickle: function () {
        var _onTrickle = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(trickle) {
          var connection;
          return runtime_1.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  connection = trickle.target === HMSConnectionRole.Publish ? _this.publishConnection : _this.subscribeConnection;

                  if (!(connection.remoteDescription === null)) {
                    _context2.next = 5;
                    break;
                  }

                  // ICE candidates can't be added without any remote session description
                  connection.candidates.push(trickle.candidate);
                  _context2.next = 7;
                  break;

                case 5:
                  _context2.next = 7;
                  return connection.addIceCandidate(trickle.candidate);

                case 7:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        function onTrickle(_x2) {
          return _onTrickle.apply(this, arguments);
        }

        return onTrickle;
      }(),
      onNotification: function onNotification(message) {
        return _this.observer.onNotification(message);
      },
      onFailure: function onFailure(exception) {
        // TODO: Init the reconnecting logic
        _this.observer.onFailure(exception);
      }
    };
    this.signal = new JsonRpcSignal(this.signalObserver);
    this.publishConnectionObserver = {
      onRenegotiationNeeded: function () {
        var _onRenegotiationNeeded = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
          var callback, offer, answer, ex;
          return runtime_1.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  HMSLogger.d(TAG$5, "\u23F3 [role=PUBLISH] onRenegotiationNeeded START", _this.tracks);
                  callback = _this.callbacks.get(RENEGOTIATION_CALLBACK_ID);

                  _this.callbacks["delete"](RENEGOTIATION_CALLBACK_ID);

                  _context3.prev = 3;
                  _context3.next = 6;
                  return _this.publishConnection.createOffer();

                case 6:
                  offer = _context3.sent;
                  _context3.next = 9;
                  return _this.publishConnection.setLocalDescription(offer);

                case 9:
                  _context3.next = 11;
                  return _this.signal.offer(offer, _this.tracks);

                case 11:
                  answer = _context3.sent;
                  _context3.next = 14;
                  return _this.publishConnection.setRemoteDescription(answer);

                case 14:
                  callback.promise.resolve(true);
                  HMSLogger.d(TAG$5, "[role=PUBLISH] onRenegotiationNeeded DONE \u2705");
                  _context3.next = 23;
                  break;

                case 18:
                  _context3.prev = 18;
                  _context3.t0 = _context3["catch"](3);

                  if (_context3.t0 instanceof HMSException) {
                    ex = _context3.t0;
                  } else {
                    ex = new HMSExceptionBuilder(HMSErrors.PeerConnectionFailed).action(callback.action).errorInfo(_context3.t0.message).build();
                  }

                  callback.promise.reject(ex);
                  HMSLogger.d(TAG$5, "[role=PUBLISH] onRenegotiationNeeded FAILED \u274C");

                case 23:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, null, [[3, 18]]);
        }));

        function onRenegotiationNeeded() {
          return _onRenegotiationNeeded.apply(this, arguments);
        }

        return onRenegotiationNeeded;
      }(),
      onIceConnectionChange: function onIceConnectionChange(newState) {
        if (newState === 'failed') {
          _this.handleIceConnectionFailure(HMSConnectionRole.Publish);
        }
      }
    };
    this.subscribeConnectionObserver = {
      onApiChannelMessage: function onApiChannelMessage(message) {
        _this.observer.onNotification(JSON.parse(message));
      },
      onTrackAdd: function onTrackAdd(track) {
        HMSLogger.d(TAG$5, '[Subscribe] onTrackAdd', track);

        _this.observer.onTrackAdd(track);
      },
      onTrackRemove: function onTrackRemove(track) {
        HMSLogger.d(TAG$5, '[Subscribe] onTrackRemove', track);

        _this.observer.onTrackRemove(track);
      },
      onIceConnectionChange: function onIceConnectionChange(newState) {
        if (newState === 'failed') {
          _this.handleIceConnectionFailure(HMSConnectionRole.Subscribe);
        }
      }
    };
    this.observer = observer;
  }

  var _proto = HMSTransport.prototype;

  _proto.handleIceConnectionFailure = function handleIceConnectionFailure(role) {
    // TODO: Should we initiate an ice-restart?
    // TODO: Should we close both peer-connections or just one?
    var ex = new HMSExceptionBuilder(HMSErrors.PeerConnectionFailed).errorInfo("[role=" + role + "] Ice connection state FAILED").build();
    this.state = TransportState.Failed;
    this.observer.onFailure(ex);
  };

  _proto.getLocalScreen = /*#__PURE__*/function () {
    var _getLocalScreen = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(settings) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return HMSLocalStream.getLocalScreen(settings);

            case 2:
              return _context4.abrupt("return", _context4.sent);

            case 3:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function getLocalScreen(_x3) {
      return _getLocalScreen.apply(this, arguments);
    }

    return getLocalScreen;
  }();

  _proto.getLocalTracks = /*#__PURE__*/function () {
    var _getLocalTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(settings) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return HMSLocalStream.getLocalTracks(settings);

            case 2:
              return _context5.abrupt("return", _context5.sent);

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    function getLocalTracks(_x4) {
      return _getLocalTracks.apply(this, arguments);
    }

    return getLocalTracks;
  }();

  _proto.join = /*#__PURE__*/function () {
    var _join = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(authToken, peerId, customData, initEndpoint, autoSubscribeVideo) {
      var config, offer, answer, _iterator2, _step2, candidate;

      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (autoSubscribeVideo === void 0) {
                autoSubscribeVideo = true;
              }

              if (!(this.state !== TransportState.Disconnected)) {
                _context6.next = 3;
                break;
              }

              throw new HMSExceptionBuilder(HMSErrors.AlreadyJoined).action(HMSAction.Join).build();

            case 3:
              _context6.next = 5;
              return InitService.fetchInitConfig(authToken, initEndpoint);

            case 5:
              config = _context6.sent;
              HMSLogger.d(TAG$5, '⏳ join: connecting to ws endpoint', config.endpoint);
              _context6.next = 9;
              return this.signal.open(config.endpoint + "?peer=" + peerId + "&token=" + authToken);

            case 9:
              HMSLogger.d(TAG$5, '✅ join: connected to ws endpoint');
              HMSLogger.d(TAG$5, customData);
              this.publishConnection = new HMSPublishConnection(this.signal, config.rtcConfiguration, this.publishConnectionObserver, this);
              this.subscribeConnection = new HMSSubscribeConnection(this.signal, config.rtcConfiguration, this.subscribeConnectionObserver);
              HMSLogger.d(TAG$5, '⏳ join: Negotiating over PUBLISH connection');
              _context6.next = 16;
              return this.publishConnection.createOffer();

            case 16:
              offer = _context6.sent;
              _context6.next = 19;
              return this.publishConnection.setLocalDescription(offer);

            case 19:
              _context6.next = 21;
              return this.signal.join(customData.name, peerId, offer, !autoSubscribeVideo);

            case 21:
              answer = _context6.sent;
              _context6.next = 24;
              return this.publishConnection.setRemoteDescription(answer);

            case 24:
              _iterator2 = _createForOfIteratorHelperLoose(this.publishConnection.candidates);

            case 25:
              if ((_step2 = _iterator2()).done) {
                _context6.next = 31;
                break;
              }

              candidate = _step2.value;
              _context6.next = 29;
              return this.publishConnection.addIceCandidate(candidate);

            case 29:
              _context6.next = 25;
              break;

            case 31:
              this.publishConnection.initAfterJoin();
              HMSLogger.d(TAG$5, '✅ join: Negotiated over PUBLISH connection'); // TODO: Handle exceptions raised - wrap them in HMSException

              HMSLogger.d(TAG$5, '✅ join: successful');

            case 34:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function join(_x5, _x6, _x7, _x8, _x9) {
      return _join.apply(this, arguments);
    }

    return join;
  }();

  _proto.leave = /*#__PURE__*/function () {
    var _leave = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7() {
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.publishConnection.close();

            case 2:
              _context7.next = 4;
              return this.subscribeConnection.close();

            case 4:
              this.signal.leave();
              _context7.next = 7;
              return this.signal.close();

            case 7:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function leave() {
      return _leave.apply(this, arguments);
    }

    return leave;
  }();

  _proto.publishTrack = /*#__PURE__*/function () {
    var _publishTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(track) {
      var _this2 = this;

      var p, stream, maxBitrate;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              HMSLogger.d(TAG$5, "\u23F3 publishTrack: trackId=" + track.trackId, track);
              this.tracks.set(track.trackId, new TrackState(track));
              p = new Promise(function (resolve, reject) {
                _this2.callbacks.set(RENEGOTIATION_CALLBACK_ID, {
                  promise: {
                    resolve: resolve,
                    reject: reject
                  },
                  action: HMSAction.Publish,
                  extra: {}
                });
              });
              stream = track.stream;
              stream.setConnection(this.publishConnection);
              stream.addTransceiver(track);
              _context8.next = 8;
              return p;

            case 8:
              // @ts-ignore
              maxBitrate = track.settings.maxBitrate;
              _context8.next = 11;
              return stream.setMaxBitrate(maxBitrate, track).then(function () {
                HMSLogger.i(TAG$5, "Setting maxBitrate for " + track.source + " " + track.type + " to " + maxBitrate + " kpbs");
              })["catch"](function (error) {
                return HMSLogger.e(TAG$5, 'Failed setting maxBitrate', error);
              });

            case 11:
              HMSLogger.d(TAG$5, "\u2705 publishTrack: trackId=" + track.trackId, this.callbacks);

            case 12:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function publishTrack(_x10) {
      return _publishTrack.apply(this, arguments);
    }

    return publishTrack;
  }();

  _proto.unpublishTrack = /*#__PURE__*/function () {
    var _unpublishTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(track) {
      var _this3 = this;

      var p, stream;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              HMSLogger.d(TAG$5, "\u23F3 unpublishTrack: trackId=" + track.trackId, track);
              this.tracks["delete"](track.trackId);
              p = new Promise(function (resolve, reject) {
                _this3.callbacks.set(RENEGOTIATION_CALLBACK_ID, {
                  promise: {
                    resolve: resolve,
                    reject: reject
                  },
                  action: HMSAction.Unpublish,
                  extra: {}
                });
              });
              stream = track.stream;
              stream.removeSender(track);
              _context9.next = 7;
              return p;

            case 7:
              HMSLogger.d(TAG$5, "\u2705 unpublishTrack: trackId=" + track.trackId, this.callbacks);

            case 8:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function unpublishTrack(_x11) {
      return _unpublishTrack.apply(this, arguments);
    }

    return unpublishTrack;
  }();

  _proto.publish = /*#__PURE__*/function () {
    var _publish = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(tracks) {
      var _iterator3, _step3, track;

      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _iterator3 = _createForOfIteratorHelperLoose(tracks);

            case 1:
              if ((_step3 = _iterator3()).done) {
                _context10.next = 7;
                break;
              }

              track = _step3.value;
              _context10.next = 5;
              return this.publishTrack(track);

            case 5:
              _context10.next = 1;
              break;

            case 7:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function publish(_x12) {
      return _publish.apply(this, arguments);
    }

    return publish;
  }();

  _proto.unpublish = /*#__PURE__*/function () {
    var _unpublish = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(tracks) {
      var _iterator4, _step4, track;

      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _iterator4 = _createForOfIteratorHelperLoose(tracks);

            case 1:
              if ((_step4 = _iterator4()).done) {
                _context11.next = 7;
                break;
              }

              track = _step4.value;
              _context11.next = 5;
              return this.unpublishTrack(track);

            case 5:
              _context11.next = 1;
              break;

            case 7:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function unpublish(_x13) {
      return _unpublish.apply(this, arguments);
    }

    return unpublish;
  }();

  _proto.sendMessage = function sendMessage(message) {
    this.signal.broadcast(message);
  };

  _proto.trackUpdate = function trackUpdate(track) {
    var currentTrackStates = Array.from(this.tracks.values());
    var originalTrackState = currentTrackStates.find(function (trackState) {
      return track.type === trackState.type && track.source === trackState.source;
    });

    if (originalTrackState) {
      var newTrackState = new TrackState(_extends({}, originalTrackState, {
        mute: !track.enabled
      }));
      this.tracks.set(originalTrackState.track_id, newTrackState);
      HMSLogger.d(TAG$5, 'Track Update', this.tracks, track);
      this.signal.trackUpdate(new Map([[originalTrackState.track_id, newTrackState]]));
    }
  };

  return HMSTransport;
}();

(function (HMSRoomUpdate) {
  HMSRoomUpdate[HMSRoomUpdate["PEER_ADDED"] = 0] = "PEER_ADDED";
  HMSRoomUpdate[HMSRoomUpdate["PEER_REMOVED"] = 1] = "PEER_REMOVED";
  HMSRoomUpdate[HMSRoomUpdate["PEER_KNOCKED"] = 2] = "PEER_KNOCKED";
  HMSRoomUpdate[HMSRoomUpdate["ROOM_TYPE_CHANGED"] = 3] = "ROOM_TYPE_CHANGED";
  HMSRoomUpdate[HMSRoomUpdate["METADATA_UPDATED"] = 4] = "METADATA_UPDATED";
  HMSRoomUpdate[HMSRoomUpdate["SCREENSHARE_STARTED"] = 5] = "SCREENSHARE_STARTED";
  HMSRoomUpdate[HMSRoomUpdate["SCREENSHARE_STOPPED"] = 6] = "SCREENSHARE_STOPPED";
  HMSRoomUpdate[HMSRoomUpdate["DEFAULT_UPDATE"] = 7] = "DEFAULT_UPDATE";
})(exports.HMSRoomUpdate || (exports.HMSRoomUpdate = {}));

(function (HMSPeerUpdate) {
  HMSPeerUpdate[HMSPeerUpdate["PEER_JOINED"] = 0] = "PEER_JOINED";
  HMSPeerUpdate[HMSPeerUpdate["PEER_LEFT"] = 1] = "PEER_LEFT";
  HMSPeerUpdate[HMSPeerUpdate["AUDIO_TOGGLED"] = 2] = "AUDIO_TOGGLED";
  HMSPeerUpdate[HMSPeerUpdate["VIDEO_TOGGLED"] = 3] = "VIDEO_TOGGLED";
  HMSPeerUpdate[HMSPeerUpdate["BECAME_DOMINANT_SPEAKER"] = 4] = "BECAME_DOMINANT_SPEAKER";
  HMSPeerUpdate[HMSPeerUpdate["RESIGNED_DOMINANT_SPEAKER"] = 5] = "RESIGNED_DOMINANT_SPEAKER";
  HMSPeerUpdate[HMSPeerUpdate["STARTED_SPEAKING"] = 6] = "STARTED_SPEAKING";
  HMSPeerUpdate[HMSPeerUpdate["STOPPED_SPEAKING"] = 7] = "STOPPED_SPEAKING";
})(exports.HMSPeerUpdate || (exports.HMSPeerUpdate = {}));

(function (HMSTrackUpdate) {
  HMSTrackUpdate[HMSTrackUpdate["TRACK_ADDED"] = 0] = "TRACK_ADDED";
  HMSTrackUpdate[HMSTrackUpdate["TRACK_REMOVED"] = 1] = "TRACK_REMOVED";
  HMSTrackUpdate[HMSTrackUpdate["TRACK_MUTED"] = 2] = "TRACK_MUTED";
  HMSTrackUpdate[HMSTrackUpdate["TRACK_UNMUTED"] = 3] = "TRACK_UNMUTED";
  HMSTrackUpdate[HMSTrackUpdate["TRACK_DESCRIPTION_CHANGED"] = 4] = "TRACK_DESCRIPTION_CHANGED";
})(exports.HMSTrackUpdate || (exports.HMSTrackUpdate = {}));

function decodeJWT(token) {
  if (token.length === 0) {
    throw new HMSExceptionBuilder(HMSErrors.MissingToken).build();
  }

  var parts = token.split('.');

  if (parts.length !== 3) {
    throw new HMSExceptionBuilder(HMSErrors.InvalidTokenFormat).build();
  }

  var payloadStr = atob(parts[1]);

  try {
    var payload = JSON.parse(payloadStr);
    return {
      roomId: payload.room_id,
      userId: payload.user_id,
      role: payload.role
    };
  } catch (err) {
    throw new HMSExceptionBuilder(HMSErrors.TokenMissingRoomId).build();
  }
}

var Peer$1 = function Peer(_ref) {
  var peerId = _ref.peerId,
      name = _ref.name,
      isLocal = _ref.isLocal,
      role = _ref.role,
      customerDescription = _ref.customerDescription;
  this.customerDescription = '';
  this.auxiliaryTracks = [];
  this.role = '';
  this.name = name;
  this.peerId = peerId;
  this.isLocal = isLocal;
  this.role = role;
  this.customerDescription = customerDescription;
};

var NotificationManager = /*#__PURE__*/function (_EventTarget) {
  _inheritsLoose(NotificationManager, _EventTarget);

  function NotificationManager() {
    var _this;

    _this = _EventTarget.apply(this, arguments) || this;
    _this.hmsPeerList = new Map();
    _this.TAG = '[Notification Manager]:';
    _this.tracksToProcess = new Map();
    _this.trackStateMap = new Map();
    _this.audioListener = null;
    /**
     * Sets the tracks to peer and returns the peer
     */

    _this.handleOnTrackAdd = function (track) {
      HMSLogger.d(_this.TAG, "ONTRACKADD", track);

      _this.tracksToProcess.set(track.trackId, track);

      _this.processPendingTracks();
    };
    /**
     * Sets the track of corresponding peer to null and returns the peer
     */


    _this.handleOnTrackRemove = function (track) {
      HMSLogger.d(_this.TAG, "ONTRACKREMOVE", track);

      var trackStateEntry = _this.trackStateMap.get(track.trackId);

      if (!trackStateEntry) return;

      var hmsPeer = _this.hmsPeerList.get(trackStateEntry.peerId);

      if (hmsPeer) {
        switch (track.type) {
          case exports.HMSTrackType.AUDIO:
            hmsPeer.audioTrack = null;
            break;

          case exports.HMSTrackType.VIDEO:
            {
              var screenShareTrackIndex = hmsPeer.auxiliaryTracks.indexOf(track);

              if (screenShareTrackIndex > -1) {
                // @TODO: change this based on source
                hmsPeer.auxiliaryTracks.splice(screenShareTrackIndex, 1);
              } else {
                hmsPeer.videoTrack = null;
              }
            }
        }

        track.type === exports.HMSTrackType.AUDIO && _this.dispatchEvent(new CustomEvent('track-removed', {
          detail: track
        }));

        _this.listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);
      }
    };

    _this.handleTrackUpdate = function (params) {
      HMSLogger.d(_this.TAG, "TRACK_UPDATE", params);

      var hmsPeer = _this.hmsPeerList.get(params.peer.peer_id);

      if (!hmsPeer) return;

      for (var _i = 0, _Object$entries = Object.entries(params.tracks); _i < _Object$entries.length; _i++) {
        var _this$trackStateMap$g;

        var _Object$entries$_i = _Object$entries[_i],
            trackId = _Object$entries$_i[0],
            trackEntry = _Object$entries$_i[1];
        var currentTrackStateInfo = Object.assign({}, (_this$trackStateMap$g = _this.trackStateMap.get(trackId)) == null ? void 0 : _this$trackStateMap$g.trackInfo);

        var track = _this.getPeerTrackByTrackId(hmsPeer.peerId, trackId);

        _this.trackStateMap.set(trackId, {
          peerId: params.peer.peer_id,
          trackInfo: _extends({}, currentTrackStateInfo, trackEntry)
        }); // TRACK_UPDATE came before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.


        if (!track || _this.tracksToProcess.has(trackId)) {
          _this.processPendingTracks();
        } else {
          track.setEnabled(!trackEntry.mute);

          if (currentTrackStateInfo.mute !== trackEntry.mute) {
            if (trackEntry.mute) {
              _this.listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_MUTED, track, hmsPeer);
            } else {
              _this.listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_UNMUTED, track, hmsPeer);
            }
          } else if (currentTrackStateInfo.description !== trackEntry.description) {
            _this.listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_DESCRIPTION_CHANGED, track, hmsPeer);
          }
        }
      }
    };

    _this.cleanUp = function () {
      _this.hmsPeerList.clear();
    };

    _this.findPeerByPeerId = function (peerId) {
      var _this$localPeer;

      if (((_this$localPeer = _this.localPeer) == null ? void 0 : _this$localPeer.peerId) === peerId) {
        return _this.localPeer;
      }

      return _this.hmsPeerList.get(peerId);
    };

    _this.handlePeerJoin = function (peer) {
      var hmsPeer = new Peer$1({
        peerId: peer.peerId,
        name: peer.info.name,
        isLocal: false,
        customerDescription: '',
        role: peer.role
      });

      _this.hmsPeerList.set(peer.peerId, hmsPeer);

      HMSLogger.d(_this.TAG, "adding to the peerList", hmsPeer);
      peer.tracks.forEach(function (track) {
        _this.trackStateMap.set(track.track_id, {
          peerId: peer.peerId,
          trackInfo: track
        });
      });

      _this.processPendingTracks();
    };

    _this.handlePeerLeave = function (peer) {
      _this.hmsPeerList["delete"](peer.peerId);
    };

    _this.handlePeerList = function (peerList) {
      var peers = peerList.peers;
      peers == null ? void 0 : peers.forEach(function (peer) {
        return _this.handlePeerJoin(peer);
      });
    };

    return _this;
  }

  var _proto = NotificationManager.prototype;

  _proto.handleNotification = function handleNotification(method, notification, listener, audioListener) {
    this.listener = listener;
    this.audioListener = audioListener;

    switch (method) {
      case HMSNotificationMethod.PEER_JOIN:
        {
          var peer = notification;
          HMSLogger.d(this.TAG, "PEER_JOIN event", peer, notification);
          this.handlePeerJoin(peer);
          break;
        }

      case HMSNotificationMethod.PEER_LEAVE:
        {
          var _peer = notification;
          HMSLogger.d(this.TAG, "PEER_LEAVE event", _peer);
          this.handlePeerLeave(_peer);
          break;
        }

      case HMSNotificationMethod.PEER_LIST:
        {
          var peerList = notification;
          HMSLogger.d(this.TAG, "PEER_LIST event", peerList);
          this.handlePeerList(peerList);
          break;
        }

      case HMSNotificationMethod.TRACK_METADATA_ADD:
        {
          this.handleTrackMetadataAdd(notification);
          break;
        }

      case HMSNotificationMethod.TRACK_UPDATE:
        {
          this.handleTrackUpdate(notification);
          break;
        }

      case HMSNotificationMethod.ROLE_CHANGE:
        {
          this.handleRoleChange(notification);
          break;
        }

      case HMSNotificationMethod.ACTIVE_SPEAKERS:
        this.handleActiveSpeakers(notification);
        break;

      default:
        return;
    }
  };

  _proto.handleRoleChange = function handleRoleChange(params) {
    // @DISCUSS: Make everything event based instead?
    this.dispatchEvent(new CustomEvent('role-change', {
      detail: {
        params: params
      }
    }));
  };

  _proto.handleTrackMetadataAdd = function handleTrackMetadataAdd(params) {
    HMSLogger.d(this.TAG, "TRACK_METADATA_ADD", params);

    for (var _i2 = 0, _Object$entries2 = Object.entries(params.tracks); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _Object$entries2[_i2],
          trackId = _Object$entries2$_i[0],
          trackEntry = _Object$entries2$_i[1];
      this.trackStateMap.set(trackId, {
        peerId: params.peer.peer_id,
        trackInfo: trackEntry
      });
    }

    this.processPendingTracks();
  };

  _proto.processPendingTracks = function processPendingTracks() {
    var _this2 = this;

    var tracksCopy = new Map(this.tracksToProcess);
    tracksCopy.forEach(function (track) {
      var state = _this2.trackStateMap.get(track.trackId);

      if (!state) return;

      var hmsPeer = _this2.hmsPeerList.get(state.peerId);

      if (!hmsPeer) return;
      track.source = state.trackInfo.source;
      track.setEnabled(!state.trackInfo.mute);

      switch (track.type) {
        case exports.HMSTrackType.AUDIO:
          if (!hmsPeer.audioTrack) {
            hmsPeer.audioTrack = track;
          } // @DISCUSS: Do we have auxilliary audio tracks too?


          break;

        case exports.HMSTrackType.VIDEO:
          if (!hmsPeer.videoTrack && track.source === 'regular') {
            hmsPeer.videoTrack = track;
          } else {
            hmsPeer.auxiliaryTracks.push(track);
          }

      }

      track.type === exports.HMSTrackType.AUDIO && _this2.dispatchEvent(new CustomEvent('track-added', {
        detail: track
      }));

      _this2.listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_ADDED, track, hmsPeer);

      _this2.tracksToProcess["delete"](track.trackId);
    });
  }
  /**
   * @param speakerList List of speakers[peer_id, level] sorted by level in descending order.
   */
  ;

  _proto.handleActiveSpeakers = function handleActiveSpeakers(speakerList) {
    var _this$audioListener;

    var speakers = speakerList.speakers;
    (_this$audioListener = this.audioListener) == null ? void 0 : _this$audioListener.onAudioLevelUpdate(speakers);
    var dominantSpeaker = speakers[0];

    if (dominantSpeaker) {
      var dominantSpeakerPeer = this.findPeerByPeerId(dominantSpeaker.peerId);
      this.listener.onPeerUpdate(exports.HMSPeerUpdate.BECAME_DOMINANT_SPEAKER, dominantSpeakerPeer);
    } else {
      this.listener.onPeerUpdate(exports.HMSPeerUpdate.RESIGNED_DOMINANT_SPEAKER, null);
    }
  };

  _proto.getPeerTrackByTrackId = function getPeerTrackByTrackId(peerId, trackId) {
    var _peer$audioTrack, _peer$videoTrack;

    var peer = this.findPeerByPeerId(peerId);

    if ((peer == null ? void 0 : (_peer$audioTrack = peer.audioTrack) == null ? void 0 : _peer$audioTrack.trackId) === trackId) {
      return peer.audioTrack;
    } else if ((peer == null ? void 0 : (_peer$videoTrack = peer.videoTrack) == null ? void 0 : _peer$videoTrack.trackId) === trackId) {
      return peer.videoTrack;
    } else {
      return peer == null ? void 0 : peer.auxiliaryTracks.find(function (track) {
        return track.trackId === trackId;
      });
    }
  };

  return NotificationManager;
}( /*#__PURE__*/_wrapNativeSuper(EventTarget));

var HMSTrackSettingsBuilder = /*#__PURE__*/function () {
  function HMSTrackSettingsBuilder() {
    this._video = new HMSVideoTrackSettingsBuilder().build();
    this._audio = new HMSAudioTrackSettingsBuilder().build();
    this._simulcast = false;
  }

  var _proto = HMSTrackSettingsBuilder.prototype;

  _proto.video = function video(_video) {
    this._video = _video;
    return this;
  };

  _proto.audio = function audio(_audio) {
    this._audio = _audio;
    return this;
  };

  _proto.simulcast = function simulcast(enabled) {
    this._simulcast = enabled;
    return this;
  };

  _proto.build = function build() {
    if (this._audio === null && this._video === null) {
      throw new HMSExceptionBuilder(HMSErrors.NothingToReturn).build();
    }

    if (this._video === null && this._simulcast) {
      throw Error('Cannot enable simulcast when no video settings are provided');
    }

    return new HMSTrackSettings(this._video, this._audio, this._simulcast);
  };

  return HMSTrackSettingsBuilder;
}();

var HMSTrackSettings = function HMSTrackSettings(video, audio, simulcast) {
  this.video = video;
  this.audio = audio;
  this.simulcast = simulcast;
};

var Room = function Room(id, name, peers) {
  this.id = id;
  this.name = name;
  this.peers = peers;
};

var SILENT_AUDIO_URL = 'https://res.cloudinary.com/dlzh3j8em/video/upload/v1619210717/silence_xko7fm.mp3';

var HMSAudioSinkManager = /*#__PURE__*/function () {
  function HMSAudioSinkManager(notificationManager, elementId) {
    var _this = this;

    this.handleTrackAdd = function (event) {
      var track = event.detail;
      var audioEl = document.createElement('audio');
      audioEl.autoplay = true;
      audioEl.style.display = 'none';
      audioEl.id = track.trackId;
      audioEl.srcObject = new MediaStream([track.nativeTrack]);

      _this.audioSink.append(audioEl);
    };

    this.handleTrackRemove = function (event) {
      var _document$getElementB;

      var track = event.detail;
      (_document$getElementB = document.getElementById(track.trackId)) == null ? void 0 : _document$getElementB.remove();
    };

    var audioSink = document.createElement('div');
    audioSink.id = "HMS-SDK-audio-sink-" + uuid.v4();
    var userElement = elementId && document.getElementById(elementId);
    var audioSinkParent = userElement || document.body;
    audioSinkParent.append(audioSink);
    this.audioSink = audioSink;
    this.addSilentAudio();
    this.notificationManager = notificationManager;
    this.notificationManager.addEventListener('track-added', this.handleTrackAdd);
    this.notificationManager.addEventListener('track-removed', this.handleTrackRemove);
  }

  var _proto = HMSAudioSinkManager.prototype;

  _proto.cleanUp = function cleanUp() {
    this.notificationManager.removeEventListener('track-added', this.handleTrackAdd);
    this.notificationManager.removeEventListener('track-removed', this.handleTrackRemove);
  };

  _proto.addSilentAudio = function addSilentAudio() {
    var silentAudio = document.createElement('audio');
    silentAudio.autoplay = true;
    silentAudio.style.display = 'none';
    silentAudio.id = "HMS-SDK-silent-audio-track-" + uuid.v4();
    silentAudio.src = SILENT_AUDIO_URL;
    this.audioSink.append(silentAudio);
  };

  return HMSAudioSinkManager;
}();

var HMSSdk = /*#__PURE__*/function () {
  function HMSSdk() {
    var _this = this;

    this.logLevel = HMSLogLevel.INFO;
    this.analyticsLevel = HMSAnalyticsLevel.OFF;
    this.TAG = '[HMSSdk]:';
    this.notificationManager = new NotificationManager();
    this.audioListener = null;
    this.published = false;
    this.publishParams = null;
    this.observer = {
      onNotification: function onNotification(message) {
        var method = getNotificationMethod(message.method);
        var notification = getNotification(method, message.params); // @TODO: Notification manager needs to be refactored. The current implementation is not manageable
        // this will pollute logs

        if (method !== HMSNotificationMethod.ACTIVE_SPEAKERS) {
          HMSLogger.d(_this.TAG, "onNotification: message=" + message);
        }

        _this.notificationManager.handleNotification(method, notification, _this.listener, _this.audioListener);

        _this.onNotificationHandled(method, notification);
      },
      onTrackAdd: function onTrackAdd(track) {
        _this.notificationManager.handleOnTrackAdd(track);
      },
      onTrackRemove: function onTrackRemove(track) {
        _this.notificationManager.handleOnTrackRemove(track);
      },
      onFailure: function onFailure(exception) {
        var _this$listener;

        (_this$listener = _this.listener) == null ? void 0 : _this$listener.onError(exception);
      }
    };
  }

  var _proto = HMSSdk.prototype;

  _proto.join = function join(config, listener) {
    var _this2 = this;

    this.notificationManager.addEventListener('role-change', function (e) {
      _this2.publishParams = e.detail.params.role.publishParams;
    });
    this.transport = new HMSTransport(this.observer);
    this.listener = listener;
    this.audioSinkManager = new HMSAudioSinkManager(this.notificationManager, config.audioSinkElementId);

    var _decodeJWT = decodeJWT(config.authToken),
        roomId = _decodeJWT.roomId,
        role = _decodeJWT.role;

    var peerId = uuid.v4();
    this.localPeer = new Peer$1({
      peerId: peerId,
      name: config.userName,
      isLocal: true,
      role: role,
      customerDescription: config.metaData
    });
    this.notificationManager.localPeer = this.localPeer;
    HMSLogger.d(this.TAG, "\u23F3 Joining room " + roomId);
    this.transport.join(config.authToken, this.localPeer.peerId, {
      name: config.userName
    }, config.initEndpoint, config.autoVideoSubscribe).then(function () {
      var _this2$listener;

      HMSLogger.d(_this2.TAG, "\u2705 Joined room " + roomId);
      _this2.roomId = roomId;

      if (!_this2.published) {
        _this2.publish(config.settings);
      }

      (_this2$listener = _this2.listener) == null ? void 0 : _this2$listener.onJoin(_this2.createRoom());
    });
  };

  _proto.cleanUp = function cleanUp() {
    this.audioSinkManager.cleanUp();
    this.notificationManager.cleanUp();
    this.published = false;
    this.localPeer = null;
    this.roomId = null;
    this.hmsRoom = null;
    this.transport = null;
    this.listener = null;
  };

  _proto.leave = /*#__PURE__*/function () {
    var _leave = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var _this$localPeer, _this$localPeer$audio, _this$localPeer2, _this$localPeer2$vide, _this$transport, roomId;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this.roomId) {
                _context.next = 9;
                break;
              }

              roomId = this.roomId;
              HMSLogger.d(this.TAG, "\u23F3 Leaving room " + roomId);
              (_this$localPeer = this.localPeer) == null ? void 0 : (_this$localPeer$audio = _this$localPeer.audioTrack) == null ? void 0 : _this$localPeer$audio.nativeTrack.stop();
              (_this$localPeer2 = this.localPeer) == null ? void 0 : (_this$localPeer2$vide = _this$localPeer2.videoTrack) == null ? void 0 : _this$localPeer2$vide.nativeTrack.stop();
              _context.next = 7;
              return (_this$transport = this.transport) == null ? void 0 : _this$transport.leave();

            case 7:
              this.cleanUp();
              HMSLogger.d(this.TAG, "\u2705 Left room " + roomId);

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function leave() {
      return _leave.apply(this, arguments);
    }

    return leave;
  }();

  _proto.getLocalPeer = function getLocalPeer() {
    return this.localPeer;
  };

  _proto.getPeers = function getPeers() {
    var remotePeers = Array.from(this.notificationManager.hmsPeerList, function (x) {
      return x[1];
    });
    var peers = this.localPeer ? [].concat(remotePeers, [this.getLocalPeer()]) : remotePeers;
    HMSLogger.d(this.TAG, "Got peers", peers);
    return peers;
  };

  _proto.sendMessage = function sendMessage(type, message, receiver) {
    var hmsMessage = new Message({
      sender: this.localPeer.peerId,
      type: type,
      message: message,
      receiver: receiver
    });
    HMSLogger.d(this.TAG, 'Sending Message:: ', hmsMessage);
    this.transport.sendMessage(hmsMessage);
    return hmsMessage;
  };

  _proto.startScreenShare = /*#__PURE__*/function () {
    var _startScreenShare = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(onStop) {
      var _this$localPeer3,
          _this$localPeer3$auxi,
          _this3 = this,
          _this$localPeer4;

      var screen, track;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              screen = this.publishParams.screen;

              if (!((((_this$localPeer3 = this.localPeer) == null ? void 0 : (_this$localPeer3$auxi = _this$localPeer3.auxiliaryTracks) == null ? void 0 : _this$localPeer3$auxi.length) || 0) > 0)) {
                _context2.next = 3;
                break;
              }

              throw Error('Cannot share multiple screens');

            case 3:
              _context2.next = 5;
              return this.transport.getLocalScreen(new HMSVideoTrackSettingsBuilder().maxBitrate(screen.bitRate).codec(screen.codec).maxFramerate(screen.frameRate).setWidth(screen.width).setHeight(screen.height).build());

            case 5:
              track = _context2.sent;

              track.nativeTrack.onended = function () {
                _this3.stopEndedScreenshare(onStop);
              };

              _context2.next = 9;
              return this.transport.publish([track]);

            case 9:
              (_this$localPeer4 = this.localPeer) == null ? void 0 : _this$localPeer4.auxiliaryTracks.push(track);

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function startScreenShare(_x) {
      return _startScreenShare.apply(this, arguments);
    }

    return startScreenShare;
  }();

  _proto.stopEndedScreenshare = /*#__PURE__*/function () {
    var _stopEndedScreenshare = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(onStop) {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              HMSLogger.d(this.TAG, "\u2705 Screenshare ended natively");
              _context3.next = 3;
              return this.stopScreenShare();

            case 3:
              onStop();

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function stopEndedScreenshare(_x2) {
      return _stopEndedScreenshare.apply(this, arguments);
    }

    return stopEndedScreenshare;
  }();

  _proto.stopScreenShare = /*#__PURE__*/function () {
    var _stopScreenShare = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4() {
      var _this$localPeer5;

      var track;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              HMSLogger.d(this.TAG, "\u2705 Screenshare ended from app");
              track = (_this$localPeer5 = this.localPeer) == null ? void 0 : _this$localPeer5.auxiliaryTracks.find(function (t) {
                return t.type === exports.HMSTrackType.VIDEO && t.source === 'screen';
              });

              if (!track) {
                _context4.next = 7;
                break;
              }

              _context4.next = 5;
              return track.setEnabled(false);

            case 5:
              this.transport.unpublish([track]);
              this.localPeer.auxiliaryTracks.splice(this.localPeer.auxiliaryTracks.indexOf(track), 1);

            case 7:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function stopScreenShare() {
      return _stopScreenShare.apply(this, arguments);
    }

    return stopScreenShare;
  }();

  _proto.addAudioListener = function addAudioListener(audioListener) {
    this.audioListener = audioListener;
  };

  _proto.onNotificationHandled = function onNotificationHandled(method, notification) {
    var _this4 = this,
        _this$listener5;

    // HMSLogger.d(this.TAG, 'onNotificationHandled', method);
    switch (method) {
      case HMSNotificationMethod.PEER_JOIN:
        {
          var peer = notification;
          var hmsPeer = this.notificationManager.findPeerByPeerId(peer.peerId);
          hmsPeer ? this.listener.onPeerUpdate(exports.HMSPeerUpdate.PEER_JOINED, hmsPeer) : HMSLogger.e(this.TAG, "\u26A0\uFE0F peer not found in peer-list", peer, this.notificationManager.hmsPeerList);
          break;
        }

      case HMSNotificationMethod.PEER_LEAVE:
        {
          var _hmsPeer$auxiliaryTra, _this$listener4;

          var _peer = notification;

          var _hmsPeer = new Peer$1({
            peerId: _peer.peerId,
            name: _peer.info.name,
            isLocal: false,
            customerDescription: _peer.info.data
          }); //@TODO: There should be a cleaner way


          if (_hmsPeer.audioTrack) {
            var _this$listener2;

            (_this$listener2 = this.listener) == null ? void 0 : _this$listener2.onTrackUpdate(exports.HMSTrackUpdate.TRACK_REMOVED, _hmsPeer.audioTrack, _hmsPeer);
          }

          if (_hmsPeer.videoTrack) {
            var _this$listener3;

            (_this$listener3 = this.listener) == null ? void 0 : _this$listener3.onTrackUpdate(exports.HMSTrackUpdate.TRACK_REMOVED, _hmsPeer.videoTrack, _hmsPeer);
          }

          (_hmsPeer$auxiliaryTra = _hmsPeer.auxiliaryTracks) == null ? void 0 : _hmsPeer$auxiliaryTra.forEach(function (track) {
            var _this4$listener;

            (_this4$listener = _this4.listener) == null ? void 0 : _this4$listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_REMOVED, track, _hmsPeer);
          });
          (_this$listener4 = this.listener) == null ? void 0 : _this$listener4.onPeerUpdate(exports.HMSPeerUpdate.PEER_LEFT, _hmsPeer);
          break;
        }

      case HMSNotificationMethod.ROLE_CHANGE:
        break;

      case HMSNotificationMethod.ACTIVE_SPEAKERS:
        break;

      case HMSNotificationMethod.BROADCAST:
        var message = notification;
        HMSLogger.d(this.TAG, "Received Message:: ", message);
        (_this$listener5 = this.listener) == null ? void 0 : _this$listener5.onMessageReceived(message);
        break;
    }
  };

  _proto.publish = function publish(settings) {
    var _this5 = this;

    var isAudioMuted = settings.isAudioMuted,
        isVideoMuted = settings.isVideoMuted,
        audioInputDeviceId = settings.audioInputDeviceId,
        videoDeviceId = settings.videoDeviceId;
    var _this$publishParams = this.publishParams,
        audio = _this$publishParams.audio,
        video = _this$publishParams.video,
        allowed = _this$publishParams.allowed;
    var canPublishAudio = allowed && allowed.includes('audio');
    var canPublishVideo = allowed && allowed.includes('video');
    HMSLogger.d(this.TAG, "Device IDs :  " + audioInputDeviceId + " ,  " + videoDeviceId + " ");
    var audioSettings = new HMSAudioTrackSettingsBuilder().codec(audio.codec).maxBitrate(audio.bitRate).deviceId(audioInputDeviceId).build();
    var videoSettings = new HMSVideoTrackSettingsBuilder().codec(video.codec).maxBitrate(video.bitRate).maxFramerate(video.frameRate).setWidth(video.width).setHeight(video.height).deviceId(videoDeviceId).build();

    if (canPublishAudio || canPublishVideo) {
      var _this$transport2;

      (_this$transport2 = this.transport) == null ? void 0 : _this$transport2.getLocalTracks(new HMSTrackSettingsBuilder().video(canPublishVideo ? videoSettings : null).audio(canPublishAudio ? audioSettings : null).build()).then( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(hmsTracks) {
          return runtime_1.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  hmsTracks.forEach( /*#__PURE__*/function () {
                    var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(hmsTrack) {
                      var _this5$localPeer, _this5$localPeer2, _this5$listener;

                      return runtime_1.wrap(function _callee5$(_context5) {
                        while (1) {
                          switch (_context5.prev = _context5.next) {
                            case 0:
                              _context5.t0 = hmsTrack.type;
                              _context5.next = _context5.t0 === exports.HMSTrackType.AUDIO ? 3 : _context5.t0 === exports.HMSTrackType.VIDEO ? 5 : 7;
                              break;

                            case 3:
                              _this5.localPeer.audioTrack = hmsTrack;
                              return _context5.abrupt("break", 7);

                            case 5:
                              _this5.localPeer.videoTrack = hmsTrack;
                              return _context5.abrupt("break", 7);

                            case 7:
                              _context5.next = 9;
                              return _this5.transport.publish([hmsTrack]);

                            case 9:
                              if (!(isAudioMuted && (_this5$localPeer = _this5.localPeer) != null && _this5$localPeer.audioTrack)) {
                                _context5.next = 12;
                                break;
                              }

                              _context5.next = 12;
                              return _this5.localPeer.audioTrack.setEnabled(false);

                            case 12:
                              if (!(isVideoMuted && (_this5$localPeer2 = _this5.localPeer) != null && _this5$localPeer2.videoTrack)) {
                                _context5.next = 15;
                                break;
                              }

                              _context5.next = 15;
                              return _this5.localPeer.videoTrack.setEnabled(false);

                            case 15:
                              (_this5$listener = _this5.listener) == null ? void 0 : _this5$listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_ADDED, hmsTrack, _this5.localPeer);

                            case 16:
                            case "end":
                              return _context5.stop();
                          }
                        }
                      }, _callee5);
                    }));

                    return function (_x4) {
                      return _ref2.apply(this, arguments);
                    };
                  }());
                  _this5.published = true;

                case 2:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        return function (_x3) {
          return _ref.apply(this, arguments);
        };
      }());
    }
  };

  _proto.createRoom = function createRoom() {
    var hmsPeerList = this.getPeers();
    this.hmsRoom = new Room(this.localPeer.peerId, '', hmsPeerList);
    return this.hmsRoom;
  };

  return HMSSdk;
}();

function getLocalStream(_x) {
  return _getLocalStream.apply(this, arguments);
}

function _getLocalStream() {
  _getLocalStream = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(constraints) {
    var stream;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return navigator.mediaDevices.getUserMedia(constraints);

          case 3:
            stream = _context.sent;
            return _context.abrupt("return", stream);

          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            throw BuildGetMediaError(_context.t0, HMSAction.GetLocalStream);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 7]]);
  }));
  return _getLocalStream.apply(this, arguments);
}

function getLocalScreen(_x2) {
  return _getLocalScreen.apply(this, arguments);
}

function _getLocalScreen() {
  _getLocalScreen = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(constraints) {
    var stream;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return navigator.mediaDevices.getDisplayMedia({
              video: constraints,
              audio: false
            });

          case 3:
            stream = _context2.sent;
            return _context2.abrupt("return", stream);

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](0);
            throw BuildGetMediaError(_context2.t0, HMSAction.GetLocalScreen);

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 7]]);
  }));
  return _getLocalScreen.apply(this, arguments);
}

function getLocalDevices() {
  return _getLocalDevices.apply(this, arguments);
}

function _getLocalDevices() {
  _getLocalDevices = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
    var devices, deviceGroups;
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return navigator.mediaDevices.enumerateDevices();

          case 3:
            devices = _context3.sent;
            deviceGroups = {
              audioinput: [],
              audiooutput: [],
              videoinput: []
            };
            devices.forEach(function (device) {
              return deviceGroups[device.kind].push(device);
            });
            return _context3.abrupt("return", deviceGroups);

          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](0);
            throw BuildGetMediaError(_context3.t0, HMSAction.GetLocalDevices);

          case 12:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 9]]);
  }));
  return _getLocalDevices.apply(this, arguments);
}

exports.HMSSdk = HMSSdk;
exports.getLocalDevices = getLocalDevices;
exports.getLocalScreen = getLocalScreen;
exports.getLocalStream = getLocalStream;
//# sourceMappingURL=100ms-web-sdk.cjs.development.js.map
