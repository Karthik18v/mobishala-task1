{"version":3,"file":"100ms-web-sdk.cjs.production.min.js","sources":["../src/interfaces/hms.ts","../src/utils/logger.ts","../node_modules/regenerator-runtime/runtime.js","../src/connection/index.ts","../src/connection/model.ts","../src/utils/constants.ts","../src/media/settings/index.ts","../src/connection/publish/index.ts","../src/media/streams/HMSMediaStream.ts","../src/media/tracks/HMSTrackType.ts","../src/media/streams/HMSRemoteStream.ts","../src/connection/HMSDataChannel.ts","../src/media/tracks/HMSTrack.ts","../src/error/HMSAction.ts","../src/media/tracks/HMSAudioTrack.ts","../src/media/tracks/HMSRemoteAudioTrack.ts","../src/media/tracks/HMSVideoTrack.ts","../src/media/tracks/HMSRemoteVideoTrack.ts","../src/connection/subscribe/index.ts","../src/signal/init/index.ts","../src/error/HMSErrors.ts","../src/media/codec.ts","../src/error/HMSException.ts","../src/signal/jsonrpc/index.ts","../src/media/settings/HMSAudioTrackSettings.ts","../src/error/HMSErrorFactory.ts","../src/utils/track.ts","../src/media/tracks/HMSLocalAudioTrack.ts","../src/media/settings/HMSVideoTrackSettings.ts","../src/media/tracks/HMSLocalVideoTrack.ts","../src/sdk/models/enums/HMSNotificationMethod.ts","../src/sdk/models/enums/HMSMessageType.ts","../src/media/streams/HMSLocalStream.ts","../src/transport/TransportState.ts","../src/sdk/models/HMSMessage.ts","../src/sdk/models/HMSSpeaker.ts","../src/sdk/models/HMSNotifications.ts","../src/transport/index.ts","../src/interfaces/update-listener.ts","../src/peer/index.ts","../src/sdk/NotificationManager.ts","../src/media/settings/HMSTrackSettings.ts","../src/sdk/models/HMSRoom.ts","../src/audio-sink-manager/index.ts","../src/utils/media.ts","../src/sdk/index.ts","../src/utils/jwt.ts"],"sourcesContent":["import HMSConfig from './config';\nimport HMSUpdateListener from './update-listener';\nimport HMSPeer from './hms-peer';\nimport HMSMessage from './message';\nimport { HMSLogLevel } from '../utils/logger';\n\nexport enum HMSAnalyticsLevel {\n  OFF,\n  ERROR,\n  INFO,\n  VERBOSE,\n}\n\nexport default interface HMS {\n  logLevel: HMSLogLevel;\n  analyticsLevel: HMSAnalyticsLevel;\n  join(config: HMSConfig, callback: HMSUpdateListener): void;\n  leave(): void;\n  getLocalPeer(): HMSPeer;\n  getPeers(): HMSPeer[];\n  sendMessage(type: string, message: string, receiver?: string): HMSMessage;\n  startScreenShare(onStop: () => void): void;\n  stopScreenShare(): void;\n}\n","export enum HMSLogLevel {\n  VERBOSE,\n  DEBUG,\n  INFO,\n  WARN,\n  ERROR,\n  NONE,\n}\n\nexport default class HMSLogger {\n  static level: HMSLogLevel = HMSLogLevel.VERBOSE;\n\n  static v(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.VERBOSE, tag, ...data);\n  }\n\n  static d(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.DEBUG, tag, ...data);\n  }\n\n  static i(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.INFO, tag, ...data);\n  }\n\n  static w(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.WARN, tag, ...data);\n  }\n\n  static e(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.ERROR, tag, ...data);\n  }\n\n  private static log(level: HMSLogLevel, tag: string, ...data: any[]) {\n    if (this.level.valueOf() > level.valueOf()) {\n      return;\n    }\n\n    switch (level) {\n      case HMSLogLevel.VERBOSE: {\n        console.log(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.DEBUG: {\n        console.debug(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.INFO: {\n        console.info(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.WARN: {\n        console.warn(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.ERROR: {\n        console.error(tag, ...data);\n        break;\n      }\n    }\n  }\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import { HMSConnectionRole } from './model';\nimport { ISignal } from '../signal/ISignal';\nimport HMSLogger from '../utils/logger';\nimport HMSTrack from '../media/tracks/HMSTrack';\n\nconst TAG = 'HMSConnection';\nexport default abstract class HMSConnection {\n  readonly role: HMSConnectionRole;\n  protected readonly signal: ISignal;\n\n  abstract readonly nativeConnection: RTCPeerConnection;\n  /**\n   * We keep a list of pending IceCandidates received\n   * from the signalling server. When the peer-connection\n   * is initialized we call [addIceCandidate] for each.\n   *\n   * WARN:\n   *  - [HMSPublishConnection] keeps the complete list of candidates (for\n   *      ice-connection failed/disconnect) forever.\n   *  - [HMSSubscribeConnection] clears this list as soon as we call [addIceCandidate]\n   */\n  readonly candidates = new Array<RTCIceCandidateInit>();\n\n  protected constructor(role: HMSConnectionRole, signal: ISignal) {\n    this.role = role;\n    this.signal = signal;\n  }\n\n  addTransceiver(track: MediaStreamTrack, init: RTCRtpTransceiverInit): RTCRtpTransceiver {\n    return this.nativeConnection.addTransceiver(track, init);\n  }\n\n  async createOffer(options: RTCOfferOptions | undefined = undefined): Promise<RTCSessionDescriptionInit> {\n    try {\n      const offer = await this.nativeConnection.createOffer(options);\n      HMSLogger.d(TAG, `[role=${this.role}] createOffer offer=${JSON.stringify(offer, null, 1)}`);\n      return offer;\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async createAnswer(options: RTCOfferOptions | undefined = undefined): Promise<RTCSessionDescriptionInit> {\n    const answer = await this.nativeConnection.createAnswer(options);\n    HMSLogger.d(TAG, `[role=${this.role}] createAnswer answer=${JSON.stringify(answer, null, 1)}`);\n    return answer;\n  }\n\n  async setLocalDescription(description: RTCSessionDescriptionInit): Promise<void> {\n    HMSLogger.d(TAG, `[role=${this.role}] setLocalDescription description=${JSON.stringify(description, null, 1)}`);\n    await this.nativeConnection.setLocalDescription(description);\n  }\n\n  async setRemoteDescription(description: RTCSessionDescriptionInit): Promise<void> {\n    try {\n      HMSLogger.d(TAG, `[role=${this.role}] setRemoteDescription description=${JSON.stringify(description, null, 1)}`);\n      await this.nativeConnection.setRemoteDescription(description);\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async addIceCandidate(candidate: RTCIceCandidateInit): Promise<void> {\n    HMSLogger.d(TAG, `[role=${this.role}] addIceCandidate candidate=${JSON.stringify(candidate, null, 1)}`);\n    await this.nativeConnection.addIceCandidate(candidate);\n  }\n\n  public get remoteDescription(): RTCSessionDescription | null {\n    return this.nativeConnection.remoteDescription;\n  }\n\n  getSenders(): Array<RTCRtpSender> {\n    return this.nativeConnection.getSenders();\n  }\n\n  removeTrack(sender: RTCRtpSender) {\n    this.nativeConnection.removeTrack(sender);\n  }\n\n  async setMaxBitrate(maxBitrate: number, track: HMSTrack) {\n    const sender = this.getSenders().find((s) => s?.track?.id === track.trackId);\n\n    if (sender) {\n      const params = sender.getParameters();\n      params.encodings[0].maxBitrate = maxBitrate * 1000;\n      await sender.setParameters(params);\n    }\n  }\n\n  async close() {\n    this.nativeConnection.close();\n  }\n}\n","export enum HMSConnectionRole {\n  Publish = 0,\n  Subscribe = 1,\n}\n\nexport interface HMSTrickle {\n  candidate: RTCIceCandidateInit;\n  target: HMSConnectionRole;\n}\n","export const RENEGOTIATION_CALLBACK_ID = 'renegotiation-callback-id';\nexport const API_DATA_CHANNEL = 'ion-sfu';\n","export enum HMSSimulcastLayer {\n  NONE = 'none',\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n}\n","import HMSConnection from '../index';\nimport { ISignal } from '../../signal/ISignal';\nimport { IPublishConnectionObserver } from './IPublishConnectionObserver';\nimport { HMSConnectionRole } from '../model';\nimport { API_DATA_CHANNEL } from '../../utils/constants';\nimport HMSLogger from '../../utils/logger';\nimport HMSTrack from '../../media/tracks/HMSTrack';\nimport HMSTransport from '../../transport';\n\nconst TAG = 'HMSPublishConnection';\n\nexport default class HMSPublishConnection extends HMSConnection {\n  private readonly observer: IPublishConnectionObserver;\n  readonly nativeConnection: RTCPeerConnection;\n  private readonly transport: HMSTransport;\n\n  constructor(\n    signal: ISignal,\n    config: RTCConfiguration,\n    observer: IPublishConnectionObserver,\n    transport: HMSTransport,\n  ) {\n    super(HMSConnectionRole.Publish, signal);\n    this.observer = observer;\n    this.transport = transport;\n\n    this.nativeConnection = new RTCPeerConnection(config);\n    this.nativeConnection.createDataChannel(API_DATA_CHANNEL, {\n      protocol: 'SCTP',\n    });\n\n    this.nativeConnection.onicecandidate = ({ candidate }) => {\n      if (candidate) {\n        signal.trickle(this.role, candidate);\n      }\n    };\n\n    this.nativeConnection.oniceconnectionstatechange = () => {\n      this.observer.onIceConnectionChange(this.nativeConnection.iceConnectionState);\n    };\n  }\n\n  initAfterJoin() {\n    this.nativeConnection.onnegotiationneeded = async () => {\n      HMSLogger.d(TAG, `onnegotiationneeded`);\n      await this.observer.onRenegotiationNeeded();\n    };\n  }\n\n  trackUpdate(track: HMSTrack) {\n    this.transport.trackUpdate(track);\n  }\n}\n","import HMSTrack from '../tracks/HMSTrack';\n\n/** @internal */\nexport default class HMSMediaStream {\n  readonly nativeStream: MediaStream;\n  readonly id: string;\n\n  readonly tracks = new Array<HMSTrack>();\n\n  constructor(nativeStream: MediaStream) {\n    this.nativeStream = nativeStream;\n    this.id = nativeStream.id;\n  }\n}\n","export enum HMSTrackType {\n  AUDIO = 'audio',\n  VIDEO = 'video',\n}\n","import HMSSubscribeConnection from '../../connection/subscribe';\nimport HMSMediaStream from './HMSMediaStream';\nimport { HMSSimulcastLayer } from '../settings';\n\n/** @internal */\nexport default class HMSRemoteStream extends HMSMediaStream {\n  private readonly connection: HMSSubscribeConnection;\n  private audio = true;\n  private video = HMSSimulcastLayer.HIGH;\n  private frameRate = HMSSimulcastLayer.HIGH;\n\n  constructor(nativeStream: MediaStream, connection: HMSSubscribeConnection) {\n    super(nativeStream);\n    this.connection = connection;\n  }\n\n  async setAudio(enabled: boolean) {\n    this.audio = enabled;\n    await this.syncWithApiChannel();\n  }\n\n  async setVideo(layer: HMSSimulcastLayer) {\n    this.video = layer;\n    await this.syncWithApiChannel();\n  }\n\n  async syncWithApiChannel() {\n    const data = {\n      streamId: this.nativeStream.id,\n      video: this.video,\n      audio: this.audio,\n      framerate: this.frameRate,\n    };\n    await this.connection.apiChannel?.send(JSON.stringify(data));\n  }\n}\n","import HMSLogger from '../utils/logger';\n\nexport interface DataChannelObserver {\n  onMessage(value: string): void;\n}\n\nexport default class HMSDataChannel {\n  private readonly TAG = 'HMSDataChannel';\n  private readonly nativeChannel: RTCDataChannel;\n  private readonly observer: DataChannelObserver;\n  private readonly metadata: string;\n  private msgQueue: string[] = [];\n\n  public get id() {\n    return this.nativeChannel.id;\n  }\n\n  public get label() {\n    return this.nativeChannel.label;\n  }\n\n  constructor(nativeChannel: RTCDataChannel, observer: DataChannelObserver, metadata: string = '') {\n    this.nativeChannel = nativeChannel;\n    this.observer = observer;\n    this.metadata = metadata;\n\n    nativeChannel.onmessage = (e) => {\n      // HMSLogger.d(this.TAG, `[${this.metadata}] onMessage: label=${this.label}, message=${e.data}`);\n      this.observer.onMessage(e.data);\n    };\n\n    nativeChannel.onopen = () => {\n      if (this.msgQueue.length > 0) {\n        HMSLogger.d('Found pending message queue, sending messages');\n        this.msgQueue.forEach((msg) => this.send(msg));\n        this.msgQueue.length = 0;\n      }\n    };\n  }\n\n  async send(message: string) {\n    if (this.nativeChannel.readyState === 'open') {\n      HMSLogger.d(this.TAG, `[${this.metadata}] Sending [size=${message.length}] message=${message}`);\n      this.nativeChannel.send(message);\n    } else {\n      HMSLogger.d(this.TAG, 'Connection is not open, queueing', message);\n      this.msgQueue.push(message);\n    }\n  }\n\n  close() {\n    this.nativeChannel.close();\n  }\n}\n","import HMSMediaStream from '../streams/HMSMediaStream';\nimport { HMSTrackType } from './HMSTrackType';\n\nexport type HMSTrackSource = 'regular' | 'screen' | 'plugin';\n\nexport default abstract class HMSTrack {\n  // @internal\n  readonly stream: HMSMediaStream;\n  source?: HMSTrackSource;\n\n  /** Changes only when un-muting the local track\n   * i.e replacing the nativeTrack with different `deviceId`\n   * track.\n   * @internal */\n  nativeTrack: MediaStreamTrack;\n\n  abstract readonly type: HMSTrackType;\n\n  public get enabled(): boolean {\n    return this.nativeTrack.enabled;\n  }\n\n  public get trackId(): string {\n    return this.nativeTrack.id;\n  }\n\n  getMediaTrackSettings(): MediaTrackSettings {\n    return this.nativeTrack.getSettings();\n  }\n\n  async setEnabled(value: boolean): Promise<void> {\n    this.nativeTrack.enabled = value;\n  }\n\n  protected constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: HMSTrackSource) {\n    this.stream = stream;\n    this.nativeTrack = track;\n    this.source = source;\n  }\n}\n","export enum HMSAction {\n  SwitchDevice,\n  GetLocalStream,\n  GetLocalScreen,\n  GetLocalDevices,\n  Join,\n  Publish,\n  Subscribe,\n  Unsubscribe,\n  Unpublish,\n  Failure,\n  Leave,\n  None,\n}\n","import HMSTrack, { HMSTrackSource } from './HMSTrack';\nimport { HMSTrackType } from './HMSTrackType';\nimport HMSMediaStream from '../streams/HMSMediaStream';\n\nexport default class HMSAudioTrack extends HMSTrack {\n  readonly type: HMSTrackType = HMSTrackType.AUDIO;\n\n  constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: string) {\n    super(stream, track, source as HMSTrackSource);\n    if (track.kind !== 'audio') throw new Error(\"Expected 'track' kind = 'audio'\");\n  }\n}\n","import HMSAudioTrack from './HMSAudioTrack';\nimport HMSRemoteStream from '../streams/HMSRemoteStream';\n\nexport default class HMSRemoteAudioTrack extends HMSAudioTrack {\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) return;\n    await super.setEnabled(value);\n    await (this.stream as HMSRemoteStream).setAudio(value);\n  }\n}\n","import HMSTrack, { HMSTrackSource } from './HMSTrack';\nimport { HMSTrackType } from './HMSTrackType';\nimport HMSMediaStream from '../streams/HMSMediaStream';\n\nexport default class HMSVideoTrack extends HMSTrack {\n  readonly type: HMSTrackType = HMSTrackType.VIDEO;\n\n  constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: string) {\n    super(stream, track, source as HMSTrackSource);\n    if (track.kind !== 'video') throw new Error(\"Expected 'track' kind = 'video'\");\n  }\n\n  addSink(videoElement: HTMLVideoElement) {\n    videoElement.srcObject = new MediaStream([this.nativeTrack]);\n  }\n\n  removeSink(videoElement: HTMLVideoElement) {\n    videoElement.srcObject = null;\n  }\n}\n","import HMSVideoTrack from './HMSVideoTrack';\nimport HMSRemoteStream from '../streams/HMSRemoteStream';\nimport { HMSSimulcastLayer } from '../settings';\n\nexport default class HMSRemoteVideoTrack extends HMSVideoTrack {\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) return;\n    await super.setEnabled(value);\n    const layer = value ? HMSSimulcastLayer.HIGH : HMSSimulcastLayer.NONE;\n    await this.preferLayer(layer);\n  }\n\n  async preferLayer(layer: HMSSimulcastLayer) {\n    await (this.stream as HMSRemoteStream).setVideo(layer);\n  }\n\n  async addSink(videoElement: HTMLVideoElement) {\n    await this.preferLayer(HMSSimulcastLayer.HIGH);\n    super.addSink(videoElement);\n  }\n\n  async removeSink(videoElement: HTMLVideoElement) {\n    await this.preferLayer(HMSSimulcastLayer.NONE);\n    super.removeSink(videoElement);\n  }\n}\n","import HMSConnection from '../index';\nimport { ISignal } from '../../signal/ISignal';\nimport ISubscribeConnectionObserver from './ISubscribeConnectionObserver';\nimport { HMSConnectionRole } from '../model';\nimport HMSRemoteStream from '../../media/streams/HMSRemoteStream';\nimport HMSDataChannel from '../HMSDataChannel';\nimport { API_DATA_CHANNEL } from '../../utils/constants';\nimport HMSRemoteAudioTrack from '../../media/tracks/HMSRemoteAudioTrack';\nimport HMSRemoteVideoTrack from '../../media/tracks/HMSRemoteVideoTrack';\n\nexport default class HMSSubscribeConnection extends HMSConnection {\n  private readonly remoteStreams = new Map<string, HMSRemoteStream>();\n\n  private readonly observer: ISubscribeConnectionObserver;\n  readonly nativeConnection: RTCPeerConnection;\n\n  private _apiChannel: HMSDataChannel | null = null;\n\n  public get apiChannel(): HMSDataChannel {\n    // TODO: Wait for the channel to be open;\n    return this._apiChannel!;\n  }\n\n  private initNativeConnectionCallbacks() {\n    this.nativeConnection.oniceconnectionstatechange = () => {\n      this.observer.onIceConnectionChange(this.nativeConnection.iceConnectionState);\n    };\n\n    this.nativeConnection.ondatachannel = (e) => {\n      if (e.channel.label !== API_DATA_CHANNEL) {\n        // TODO: this.observer.onDataChannel(e.channel);\n        return;\n      }\n\n      this._apiChannel = new HMSDataChannel(\n        e.channel,\n        {\n          onMessage: (value: string) => {\n            this.observer.onApiChannelMessage(value);\n          },\n        },\n        `role=${this.role}`,\n      );\n    };\n\n    this.nativeConnection.onicecandidate = (e) => {\n      if (e.candidate !== null) {\n        this.signal.trickle(this.role, e.candidate);\n      }\n    };\n\n    this.nativeConnection.ontrack = (e) => {\n      const stream = e.streams[0];\n      if (!this.remoteStreams.has(stream.id)) {\n        const remote = new HMSRemoteStream(stream, this);\n        this.remoteStreams.set(stream.id, remote);\n\n        stream.onremovetrack = (e) => {\n          const toRemoveTrackIdx = remote.tracks.findIndex((track) => track.trackId === e.track.id);\n          if (toRemoveTrackIdx >= 0) {\n            const toRemoveTrack = remote.tracks[toRemoveTrackIdx];\n            this.observer.onTrackRemove(toRemoveTrack);\n            remote.tracks.splice(toRemoveTrackIdx, 1);\n\n            // If the length becomes 0 we assume that stream is removed entirely\n            if (remote.tracks.length === 0) {\n              this.remoteStreams.delete(stream.id);\n            }\n          }\n        };\n      }\n\n      const remote = this.remoteStreams.get(stream.id)!;\n      const TrackCls = e.track.kind === 'audio' ? HMSRemoteAudioTrack : HMSRemoteVideoTrack;\n      const track = new TrackCls(remote, e.track);\n      remote.tracks.push(track);\n      this.observer.onTrackAdd(track);\n    };\n  }\n\n  constructor(signal: ISignal, config: RTCConfiguration, observer: ISubscribeConnectionObserver) {\n    super(HMSConnectionRole.Subscribe, signal);\n    this.observer = observer;\n\n    this.nativeConnection = new RTCPeerConnection(config);\n    this.initNativeConnectionCallbacks();\n  }\n\n  async close() {\n    await super.close();\n    this.apiChannel?.close();\n  }\n}\n","import { InitConfig } from './models';\nimport HMSLogger from '../../utils/logger';\n\nconst TAG = 'InitService';\n\nexport default class InitService {\n  static async fetchInitConfig(\n    token: string,\n    initEndpoint: string = 'https://qa-init.100ms.live/init',\n    region: string = '',\n  ): Promise<InitConfig> {\n    HMSLogger.d(TAG, `fetchInitConfig: initEndpoint=${initEndpoint} token=${token} region=${region}`);\n    let url = `${initEndpoint}?token=${token}`;\n    if (region.length > 0) {\n      url += `&region=${region}`;\n    }\n\n    // @TODO: Add user-agent, handle error status codes\n    const response = await fetch(url);\n    return (await response.json()) as InitConfig;\n  }\n}\n","/*\n * HMSErrors.ts\n *\n * Created by codegen\n * Copyright Â© 2021 100ms. All rights reserved.\n */\n\nexport interface CodeMessage {\n  code: number;\n  messageTemplate: string;\n  requiresAction: boolean;\n  requiresErrorInfo: boolean;\n}\n\nconst HMSErrors = {\n  /* Connection Errors */\n\n  // Generic error\n  GenericConnect: {\n    code: 1000,\n    messageTemplate: `Something went wrong`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Auth token is missing\n  MissingToken: {\n    code: 1001,\n    messageTemplate: `Auth token is missing`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Token is not in proper JWT format\n  InvalidTokenFormat: {\n    code: 1002,\n    messageTemplate: `This auth token format is not supported`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Token is missing room id parameter\n  TokenMissingRoomId: {\n    code: 1003,\n    messageTemplate: `Auth token is missing room id field`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // SDK cannot establish websocket connection\n  NetworkUnavailable: {\n    code: 1004,\n    messageTemplate: `Could not connect. Please check your internet connection and try again`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Token is not authorised/expired\n  TokenNotAuthorised: {\n    code: 1005,\n    messageTemplate: `Auth token is not valid`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Endpoint url is malformed\n  InvalidEndpointUrl: {\n    code: 1006,\n    messageTemplate: `Endpoint URL is invalid`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Endpoint is not responding\n  EndpointUnreachable: {\n    code: 1007,\n    messageTemplate: `Endpoint is not reachable`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Signalling websocket connection failed / RTC Peer connection failed\n  ConnectionLost: {\n    code: 1008,\n    messageTemplate: `Connection to server is lost. {error_info}`,\n    requiresAction: false,\n    requiresErrorInfo: true,\n  },\n  /* Local Stream Errors */\n\n  // Generic error\n  GenericStream: {\n    code: 2000,\n    messageTemplate: `Something went wrong`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Both publish audio/video is off nothing to return\n  NothingToReturn: {\n    code: 2001,\n    messageTemplate: `There is no media to return. Please select either video or audio or both`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Trying to change codec on the fly\n  CodecChangeNotPermitted: {\n    code: 2002,\n    messageTemplate: `Codec can't be changed mid call`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Trying to change publish video/audio mid call\n  PublishSettingsCantBeChanged: {\n    code: 2003,\n    messageTemplate: `Publish options can't be changed mid call`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // User denied permission to access capture device\n  CantAccessCaptureDevice: {\n    code: 2004,\n    messageTemplate: `No permission to access capture device`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // WEB: Capture device is no longer available (usb cam is not connected)\n  DeviceNotAvailable: {\n    code: 2005,\n    messageTemplate: `Capture device is no longer available`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // WEB: Capture device is in use by another application\n  DeviceInUse: {\n    code: 2006,\n    messageTemplate: `Capture device is in use by another application`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  /* Room Join/Leave Errors */\n\n  // Generic error\n  GenericJoin: {\n    code: 3000,\n    messageTemplate: `Something went wrong`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Unknown room id\n  UnkownRoom: {\n    code: 3001,\n    messageTemplate: `This room id is not recongnised.`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Already joined\n  AlreadyJoined: {\n    code: 3002,\n    messageTemplate: `You have already joined this room.`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Max room participants reached\n  RoomParticipantLimitReached: {\n    code: 3004,\n    messageTemplate: `You can't join this room because it is already full.`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  /* Room Actions Errors */\n\n  // Generic error\n  GenericAction: {\n    code: 4100,\n    messageTemplate: `[{action}]: Something went wrong`,\n    requiresAction: true,\n    requiresErrorInfo: false,\n  },\n  // Has not joined the room\n  NotInTheRoom: {\n    code: 4101,\n    messageTemplate: `[{action}]: You need to join the room before you can publish.`,\n    requiresAction: true,\n    requiresErrorInfo: false,\n  },\n  // Malformed server response (i.e sdp missing)\n  InvalidServerResponse: {\n    code: 4102,\n    messageTemplate: `[{action}]: Unknown server response. {error_info} `,\n    requiresAction: true,\n    requiresErrorInfo: true,\n  },\n  // Failed to establish RTCPeerConnection\n  PeerConnectionFailed: {\n    code: 4103,\n    messageTemplate: `[{action}]: Could not establish a peer connection. {error_info} `,\n    requiresAction: true,\n    requiresErrorInfo: true,\n  },\n  // Can't unpublish a stream that is not published\n  UnpublishCalledBeforePublish: {\n    code: 4104,\n    messageTemplate: `Can't unpublish a stream that is not published`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  /* Generic Errors */\n\n  // Not connected\n  NotConnected: {\n    code: 5000,\n    messageTemplate: `Client is not connected`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n  // Generic signalling error. I.e server is returning error response to some command but the SDK doesn't know how to handle.\n  Signalling: {\n    code: 5001,\n    messageTemplate: `Unknown signalling error: {action} {error_info} `,\n    requiresAction: true,\n    requiresErrorInfo: true,\n  },\n  // Generic SDK error. Some unforseen exception happened.\n  Unknown: {\n    code: 5002,\n    messageTemplate: `Unknown exception: {error_info}`,\n    requiresAction: false,\n    requiresErrorInfo: true,\n  },\n  // Webrtc stack not initialised yet\n  NotReady: {\n    code: 5003,\n    messageTemplate: `WebRTC engine is not ready yet`,\n    requiresAction: false,\n    requiresErrorInfo: false,\n  },\n};\n\nexport default HMSErrors;\n","export enum HMSVideoCodec {\n  VP8 = 'vp8',\n  VP9 = 'vp9',\n  H264 = 'h264',\n}\n\nexport enum HMSAudioCodec {\n  OPUS = 'opus',\n}\n","import { HMSAction } from './HMSAction';\nimport HMSErrors, { CodeMessage } from './HMSErrors';\n\nexport class HMSExceptionBuilder {\n  private readonly cm: CodeMessage;\n  private _action: string | null = null;\n  private _errorInfo: string | null = null;\n\n  constructor(codeMessage: CodeMessage) {\n    this.cm = codeMessage;\n  }\n\n  action(action: HMSAction) {\n    this._action = HMSAction[action].toString();\n    return this;\n  }\n\n  errorInfo(errorInfo: string) {\n    this._errorInfo = errorInfo;\n    return this;\n  }\n\n  static from(code: number, message: string, requiresAction: boolean = false, requiresErrorInfo: boolean = false) {\n    const cm = {\n      code,\n      messageTemplate: message,\n      requiresAction,\n      requiresErrorInfo,\n    };\n    if (!message.includes('{action}') && requiresAction) {\n      cm.messageTemplate = `[{action}] ${cm.messageTemplate}`;\n    }\n\n    if (!message.includes('{error_info}') && requiresAction) {\n      cm.messageTemplate = `${cm.messageTemplate}. {error_info}`;\n    }\n\n    return new HMSExceptionBuilder(cm);\n  }\n\n  build(): HMSException {\n    const { code, requiresAction, requiresErrorInfo } = this.cm;\n    const hmsErrorEntry = Object.entries(HMSErrors).find((errorEntry) => errorEntry[1].code === code);\n    const title = (hmsErrorEntry && hmsErrorEntry[0]) || '';\n    let message = this.cm.messageTemplate;\n    if (requiresAction && this._action === null) {\n      throw Error(`${code}: ${message} requires action property`);\n    } else if (requiresAction) {\n      message = message.replace('{action}', this._action!);\n    } else if (this._action !== null) {\n      message = `[${this._action}] ${message}`;\n    }\n\n    if (requiresErrorInfo && this._errorInfo === null) {\n      throw Error(`${code}: ${message} requires errorInfo property`);\n    } else if (requiresErrorInfo) {\n      message = message.replace('{error_info}', this._errorInfo!);\n    } else if (this._errorInfo !== null) {\n      message = `${message}. ${this._errorInfo}`;\n    }\n\n    return new HMSException(this.cm.code, title, message);\n  }\n}\n\nexport default class HMSException extends Error {\n  readonly code: number;\n  readonly title: string = '';\n\n  constructor(code: number, title: string, message: string) {\n    super(message);\n\n    // Ref: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, HMSException.prototype);\n    this.name = 'HMSException';\n    this.title = title;\n    this.code = code;\n  }\n}\n","import { v4 as uuid } from 'uuid';\nimport { ISignal, Track } from '../ISignal';\nimport { ISignalEventsObserver } from '../ISignalEventsObserver';\nimport { HMSConnectionRole, HMSTrickle } from '../../connection/model';\nimport { JsonRpcRequest } from './models';\nimport { HMSExceptionBuilder } from '../../error/HMSException';\nimport { PromiseCallbacks } from '../../utils/promise';\nimport HMSLogger from '../../utils/logger';\nimport HMSErrors from '../../error/HMSErrors';\nimport HMSMessage from '../../interfaces/message';\n\nexport default class JsonRpcSignal implements ISignal {\n  private readonly TAG = '[ SIGNAL ]: ';\n  readonly observer: ISignalEventsObserver;\n\n  /**\n   * Sometimes before [join] is completed, there could be a lot of trickles\n   * Sending [HMSTrickle]` before [join] web socket message leads to\n   * error: [500] no rtc transport exists for this Peer\n   *\n   * We keep a list of pending trickles and send them immediately after [join]\n   * is done.\n   */\n  private isJoinCompleted: boolean = false;\n  private pendingTrickle: Array<HMSTrickle> = [];\n\n  private socket: WebSocket | null = null;\n\n  private callbacks = new Map<string, PromiseCallbacks<string>>();\n\n  constructor(observer: ISignalEventsObserver) {\n    this.observer = observer;\n  }\n\n  private async call<T>(method: string, params: any): Promise<T> {\n    const id = uuid();\n    const message = { method, params, id } as JsonRpcRequest;\n\n    this.socket!.send(JSON.stringify(message));\n\n    const response = await new Promise<string>((resolve, reject) => {\n      this.callbacks.set(id, { resolve, reject });\n    });\n\n    return JSON.parse(response);\n  }\n\n  private notify(method: string, params: any) {\n    const message = { method, params };\n\n    this.socket!.send(JSON.stringify(message));\n  }\n\n  open(uri: string): Promise<void> {\n    return new Promise((resolve) => {\n      this.socket = new WebSocket(uri); // @DISCUSS: Inject WebSocket as a dependency so that it can be easier to mock and test\n      const openHandler = () => {\n        resolve();\n        this.socket!.removeEventListener('open', openHandler);\n      };\n\n      this.socket.addEventListener('open', openHandler);\n      this.socket.addEventListener('close', (e) => {\n        // https://stackoverflow.com/questions/18803971/websocket-onerror-how-to-read-error-description\n        if (e.code !== 1000) {\n          // 1000 code indicated `Normal Closure` [https://tools.ietf.org/html/rfc6455#section-7.4.1]\n          const error = new HMSExceptionBuilder(HMSErrors.ConnectionLost).errorInfo(`${e.reason} [${e.code}]`).build();\n          this.observer.onFailure(error);\n        }\n      });\n      this.socket.addEventListener('message', (event) => this.onMessageHandler(event.data));\n    });\n  }\n\n  async close(): Promise<void> {\n    const p = new Promise<void>((resolve) => {\n      this.socket!.addEventListener('close', () => resolve());\n    });\n\n    // For `1000` Refer: https://tools.ietf.org/html/rfc6455#section-7.4.1\n    this.socket!.close(1000, 'Normal Close');\n    return p;\n  }\n\n  async join(\n    name: string,\n    data: string,\n    offer: RTCSessionDescriptionInit,\n    disableVidAutoSub: boolean,\n  ): Promise<RTCSessionDescriptionInit> {\n    const params = { name, disableVidAutoSub, data, offer };\n    const response: RTCSessionDescriptionInit = await this.call('join', params);\n\n    this.isJoinCompleted = true;\n    this.pendingTrickle.forEach(({ target, candidate }) => this.trickle(target, candidate));\n    this.pendingTrickle.length = 0;\n\n    HMSLogger.d(this.TAG, `join: response=${JSON.stringify(response, null, 1)}`);\n    return response;\n  }\n\n  trickle(target: HMSConnectionRole, candidate: RTCIceCandidateInit) {\n    if (this.isJoinCompleted) {\n      this.notify('trickle', { target, candidate });\n    } else {\n      this.pendingTrickle.push({ target, candidate });\n    }\n  }\n\n  async offer(desc: RTCSessionDescriptionInit, tracks: Map<string, any>): Promise<RTCSessionDescriptionInit> {\n    const response = await this.call('offer', {\n      desc,\n      tracks: Object.fromEntries(tracks),\n    });\n    return response as RTCSessionDescriptionInit;\n  }\n\n  answer(desc: RTCSessionDescriptionInit) {\n    this.notify('answer', { desc });\n  }\n\n  trackUpdate(tracks: Map<string, Track>) {\n    HMSLogger.d(this.TAG, 'Track Update: ', { tracks: Object.fromEntries(tracks) });\n    this.notify('track-update', { version: '1.0', tracks: Object.fromEntries(tracks) });\n  }\n\n  broadcast(message: HMSMessage) {\n    // Refer https://www.notion.so/100ms/Biz-Client-Communication-V2-0e93bf0fcd0d46d49e96099d498112d8#b6dd01c8e258442fb50c11c87e4581fb\n    this.notify('broadcast', { version: '1.0', info: message });\n  }\n\n  recordStart() {}\n\n  recordEnd() {}\n\n  leave() {\n    this.notify('leave', { version: '1.0' });\n  }\n\n  analytics() {}\n\n  private onMessageHandler(text: string) {\n    const response = JSON.parse(text);\n\n    if (response.hasOwnProperty('id')) {\n      /** This is a response to [call] */\n      const id: string = response.id;\n      if (this.callbacks.has(id)) {\n        const cb = this.callbacks.get(id)!;\n        this.callbacks.delete(id);\n        if (response.result) {\n          cb.resolve(JSON.stringify(response.result));\n        } else {\n          const error = response.error;\n          const ex = HMSExceptionBuilder.from(error.code, error.message).build();\n          cb.reject(ex);\n        }\n      } else {\n        this.observer.onNotification(response);\n      }\n    } else if (response.hasOwnProperty('method')) {\n      if (response.method === 'offer') {\n        this.observer.onOffer(response.params);\n      } else if (response.method === 'trickle') {\n        this.observer.onTrickle(response.params);\n      } else {\n        this.observer.onNotification(response);\n      }\n    } else throw Error(`WebSocket message has no 'method' or 'id' field, message=${response}`);\n  }\n}\n","import { HMSAudioCodec } from '../codec';\n\nexport class HMSAudioTrackSettingsBuilder {\n  private _volume: number = 1.0;\n  private _codec: HMSAudioCodec = HMSAudioCodec.OPUS;\n  private _maxBitrate: number = 32_000;\n  private _deviceId: string = 'default';\n  private _advanced: Array<MediaTrackConstraintSet> = [\n    // @ts-ignore\n    { googEchoCancellation: { exact: true } },\n    // @ts-ignore\n    { googExperimentalEchoCancellation: { exact: true } },\n    { autoGainControl: { exact: true } },\n    { noiseSuppression: { exact: true } },\n    // @ts-ignore\n    { googHighpassFilter: { exact: true } },\n    // @ts-ignore\n    { googAudioMirroring: { exact: true } },\n  ];\n\n  volume(volume: number) {\n    if (!(0.0 <= volume && volume <= 1.0)) throw Error('volume can only be in range [0.0, 1.0]');\n    this._volume = volume;\n    return this;\n  }\n\n  codec(codec: HMSAudioCodec) {\n    this._codec = codec;\n    return this;\n  }\n\n  maxBitrate(maxBitrate: number) {\n    if (maxBitrate <= 0) throw Error('maxBitrate should be >= 1');\n    this._maxBitrate = maxBitrate;\n    return this;\n  }\n\n  deviceId(deviceId: string) {\n    // TODO: Validate if device-id is OK\n    this._deviceId = deviceId;\n    return this;\n  }\n\n  advanced(advanced: Array<MediaTrackConstraintSet>) {\n    this._advanced = advanced;\n    return this;\n  }\n\n  build() {\n    return new HMSAudioTrackSettings(this._volume, this._codec, this._maxBitrate, this._deviceId, this._advanced);\n  }\n}\n\nexport default class HMSAudioTrackSettings {\n  readonly volume: number;\n  readonly codec: HMSAudioCodec;\n  readonly maxBitrate: number;\n  readonly deviceId: string;\n  readonly advanced: Array<MediaTrackConstraintSet>;\n\n  constructor(\n    volume: number,\n    codec: HMSAudioCodec,\n    maxBitrate: number,\n    deviceId: string,\n    advanced: Array<MediaTrackConstraintSet>,\n  ) {\n    this.volume = volume;\n    this.codec = codec;\n    this.maxBitrate = maxBitrate;\n    this.deviceId = deviceId;\n    this.advanced = advanced;\n  }\n\n  toConstraints(): MediaTrackConstraints {\n    return {\n      deviceId: this.deviceId,\n      advanced: this.advanced,\n    };\n  }\n}\n","import HMSLogger from '../utils/logger';\nimport { HMSAction } from './HMSAction';\nimport HMSErrors from './HMSErrors';\nimport HMSException, { HMSExceptionBuilder } from './HMSException';\n\nconst TAG = 'HMSErrorFactory';\n\nexport function BuildGetMediaError(err: Error, action: HMSAction): HMSException {\n  HMSLogger.e(TAG, `getLocalScreen`, err);\n  const message = err.message.toLowerCase();\n\n  switch (err.name) {\n    case 'OverconstrainedError':\n      return new HMSExceptionBuilder(HMSErrors.Unknown).action(action).errorInfo(err.message).build();\n    case 'NotAllowedError':\n      return new HMSExceptionBuilder(HMSErrors.CantAccessCaptureDevice).action(action).errorInfo(err.message).build();\n    case 'NotFoundError':\n      return new HMSExceptionBuilder(HMSErrors.DeviceNotAvailable).action(action).errorInfo(err.message).build();\n    case 'NotReadableError':\n      return new HMSExceptionBuilder(HMSErrors.DeviceInUse).action(action).errorInfo(err.message).build();\n    case 'TypeError':\n      return new HMSExceptionBuilder(HMSErrors.NothingToReturn).action(action).errorInfo(err.message).build();\n    default:\n      if (message.includes('device not found')) {\n        return new HMSExceptionBuilder(HMSErrors.DeviceNotAvailable).action(action).errorInfo(err.message).build();\n      } else if (message.includes('permission denied')) {\n        return new HMSExceptionBuilder(HMSErrors.CantAccessCaptureDevice).action(action).errorInfo(err.message).build();\n      } else {\n        return new HMSExceptionBuilder(HMSErrors.Unknown).action(action).errorInfo(err.message).build();\n      }\n  }\n}\n","import { HMSAction } from '../error/HMSAction';\nimport { BuildGetMediaError } from '../error/HMSErrorFactory';\nimport HMSAudioTrackSettings from '../media/settings/HMSAudioTrackSettings';\nimport HMSVideoTrackSettings from '../media/settings/HMSVideoTrackSettings';\n\nexport async function getAudioTrack(settings: HMSAudioTrackSettings): Promise<MediaStreamTrack> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: settings.toConstraints(),\n    });\n    return stream.getAudioTracks()[0];\n  } catch (err) {\n    throw BuildGetMediaError(err, HMSAction.SwitchDevice);\n  }\n}\n\nexport async function getVideoTrack(settings: HMSVideoTrackSettings): Promise<MediaStreamTrack> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: settings.toConstraints(),\n    });\n    return stream.getVideoTracks()[0];\n  } catch (err) {\n    throw BuildGetMediaError(err, HMSAction.SwitchDevice);\n  }\n}\n\n// the dimensions of the passed in track are used to create the empty video track\nexport function getEmptyVideoTrack(prevTrack?: MediaStreamTrack) {\n  const width = prevTrack?.getSettings()?.width || 640;\n  const height = prevTrack?.getSettings()?.height || 360;\n  const canvas = Object.assign(document.createElement('canvas'), { width, height }) as any;\n  canvas.getContext('2d')?.fillRect(0, 0, width, height);\n  const stream = canvas.captureStream();\n  const emptyTrack = stream.getVideoTracks()[0];\n  emptyTrack.enabled = false;\n  return emptyTrack;\n}\n","import HMSAudioTrack from './HMSAudioTrack';\nimport HMSLocalStream from '../streams/HMSLocalStream';\nimport HMSAudioTrackSettings from '../settings/HMSAudioTrackSettings';\nimport { getAudioTrack } from '../../utils/track';\n\nfunction generateHasPropertyChanged(newSettings: HMSAudioTrackSettings, oldSettings: HMSAudioTrackSettings) {\n  return function hasChanged(prop: 'codec' | 'volume' | 'maxBitrate' | 'deviceId' | 'advanced') {\n    return prop in newSettings && newSettings[prop] !== oldSettings[prop];\n  };\n}\n\nexport default class HMSLocalAudioTrack extends HMSAudioTrack {\n  settings: HMSAudioTrackSettings;\n\n  constructor(stream: HMSLocalStream, track: MediaStreamTrack, settings: HMSAudioTrackSettings, source: string) {\n    super(stream, track, source);\n    stream.tracks.push(this);\n\n    this.settings = settings;\n  }\n\n  private async replaceTrackWith(settings: HMSAudioTrackSettings) {\n    const prevTrack = this.nativeTrack;\n    const withTrack = await getAudioTrack(settings);\n    await (this.stream as HMSLocalStream).replaceTrack(this, withTrack);\n    prevTrack?.stop();\n  }\n\n  async setEnabled(value: boolean) {\n    if (value === this.enabled) return;\n    await super.setEnabled(value);\n    (this.stream as HMSLocalStream).trackUpdate(this);\n  }\n\n  async setSettings(settings: HMSAudioTrackSettings) {\n    const { volume, codec, maxBitrate, deviceId, advanced } = { ...this.settings, ...settings };\n    const newSettings = new HMSAudioTrackSettings(volume, codec, maxBitrate, deviceId, advanced);\n    const stream = this.stream as HMSLocalStream;\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n\n    if (hasPropertyChanged('deviceId')) {\n      await this.replaceTrackWith(newSettings);\n    }\n\n    if (hasPropertyChanged('maxBitrate')) {\n      await stream.setMaxBitrate(newSettings.maxBitrate, this);\n    }\n\n    if (hasPropertyChanged('advanced')) {\n      await this.nativeTrack.applyConstraints(newSettings.toConstraints());\n    }\n\n    this.settings = newSettings;\n  }\n}\n","import { HMSVideoCodec } from '../codec';\n\nexport class HMSVideoResolution {\n  readonly width: number;\n  readonly height: number;\n\n  constructor(width: number, height: number) {\n    if (width <= 0) throw Error('Height should be >= 1');\n    if (height <= 0) throw Error('Height should be >= 1');\n\n    this.width = width;\n    this.height = height;\n  }\n}\n\nexport class HMSVideoTrackSettingsBuilder {\n  private _width: number = 320;\n  private _height: number = 180;\n  private _codec: HMSVideoCodec = HMSVideoCodec.VP8;\n  private _maxFramerate: number = 30;\n  private _maxBitrate: number = 150_000;\n  private _deviceId: string = 'default';\n  private _advanced: Array<MediaTrackConstraintSet> = [];\n\n  setWidth(width: number) {\n    this._width = width;\n    return this;\n  }\n\n  setHeight(height: number) {\n    this._height = height;\n    return this;\n  }\n\n  codec(codec: HMSVideoCodec) {\n    this._codec = codec;\n    return this;\n  }\n\n  maxFramerate(maxFramerate: number) {\n    if (maxFramerate <= 0) throw Error('maxFramerate should be >= 1');\n    this._maxFramerate = maxFramerate;\n    return this;\n  }\n\n  maxBitrate(maxBitrate: number) {\n    if (maxBitrate <= 0) throw Error('maxBitrate should be >= 1');\n    this._maxBitrate = maxBitrate;\n    return this;\n  }\n\n  deviceId(deviceId: string) {\n    // TODO: Validate if device-id is OK\n    this._deviceId = deviceId;\n    return this;\n  }\n\n  advanced(advanced: Array<MediaTrackConstraintSet>) {\n    this._advanced = advanced;\n    return this;\n  }\n\n  build() {\n    return new HMSVideoTrackSettings(\n      this._width,\n      this._height,\n      this._codec,\n      this._maxFramerate,\n      this._maxBitrate,\n      this._deviceId,\n      this._advanced,\n    );\n  }\n}\n\nexport default class HMSVideoTrackSettings {\n  readonly width: number;\n  readonly height: number;\n  readonly codec: HMSVideoCodec;\n  readonly maxFramerate: number;\n  readonly maxBitrate: number;\n  readonly deviceId: string;\n  readonly advanced: Array<MediaTrackConstraintSet>;\n\n  constructor(\n    width: number,\n    height: number,\n    codec: HMSVideoCodec,\n    maxFramerate: number,\n    maxBitrate: number,\n    deviceId: string,\n    advanced: Array<MediaTrackConstraintSet>,\n  ) {\n    this.width = width;\n    this.height = height;\n    this.codec = codec;\n    this.maxFramerate = maxFramerate;\n    this.maxBitrate = maxBitrate;\n    this.deviceId = deviceId;\n    this.advanced = advanced;\n  }\n\n  toConstraints(): MediaTrackConstraints {\n    return {\n      width: this.width,\n      height: this.height,\n      frameRate: this.maxFramerate,\n      deviceId: this.deviceId,\n    };\n  }\n}\n","import HMSVideoTrack from './HMSVideoTrack';\nimport HMSLocalStream from '../streams/HMSLocalStream';\nimport HMSVideoTrackSettings from '../settings/HMSVideoTrackSettings';\nimport { getEmptyVideoTrack, getVideoTrack } from '../../utils/track';\n\nfunction generateHasPropertyChanged(newSettings: HMSVideoTrackSettings, oldSettings: HMSVideoTrackSettings) {\n  return function hasChanged(\n    prop: 'codec' | 'width' | 'height' | 'maxFramerate' | 'maxBitrate' | 'deviceId' | 'advanced',\n  ) {\n    return prop in newSettings && newSettings[prop] !== oldSettings[prop];\n  };\n}\n\nexport default class HMSLocalVideoTrack extends HMSVideoTrack {\n  settings: HMSVideoTrackSettings;\n\n  constructor(stream: HMSLocalStream, track: MediaStreamTrack, settings: HMSVideoTrackSettings, source: string) {\n    super(stream, track, source);\n    stream.tracks.push(this);\n\n    this.settings = settings;\n  }\n\n  private async replaceTrackWith(settings: HMSVideoTrackSettings) {\n    const prevTrack = this.nativeTrack;\n    const withTrack = await getVideoTrack(settings);\n    await (this.stream as HMSLocalStream).replaceTrack(this, withTrack);\n    prevTrack?.stop();\n  }\n\n  private async replaceTrackWithBlank() {\n    const prevTrack = this.nativeTrack;\n    const withTrack = getEmptyVideoTrack(prevTrack);\n    await (this.stream as HMSLocalStream).replaceTrack(this, withTrack);\n    prevTrack?.stop();\n  }\n\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) return;\n    await super.setEnabled(value);\n    (this.stream as HMSLocalStream).trackUpdate(this);\n    if (value) {\n      await this.replaceTrackWith(this.settings);\n    } else {\n      await this.replaceTrackWithBlank();\n    }\n  }\n\n  async setSettings(settings: HMSVideoTrackSettings) {\n    const { width, height, codec, maxFramerate, maxBitrate, deviceId, advanced } = { ...this.settings, ...settings };\n    const newSettings = new HMSVideoTrackSettings(width, height, codec, maxFramerate, maxBitrate, deviceId, advanced);\n    const stream = this.stream as HMSLocalStream;\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n\n    if (hasPropertyChanged('deviceId')) {\n      await this.replaceTrackWith(newSettings);\n    }\n\n    if (hasPropertyChanged('maxBitrate')) {\n      await stream.setMaxBitrate(newSettings.maxBitrate, this);\n    }\n\n    if (hasPropertyChanged('width') || hasPropertyChanged('height') || hasPropertyChanged('advanced')) {\n      await this.nativeTrack.applyConstraints(newSettings.toConstraints());\n    }\n\n    this.settings = newSettings;\n  }\n}\n","import HMSLogger from '../../../utils/logger';\n\nexport enum HMSNotificationMethod {\n  PEER_JOIN,\n  PEER_LEAVE,\n  PEER_LIST,\n  ACTIVE_SPEAKERS,\n  BROADCAST,\n  ROLE_CHANGE,\n  TRACK_METADATA_ADD,\n  TRACK_UPDATE,\n  UNSUPPORTED,\n}\n\nexport const getNotificationMethod = (method: string) => {\n  switch (method) {\n    case 'on-peer-join':\n      return HMSNotificationMethod.PEER_JOIN;\n    case 'on-peer-leave':\n      return HMSNotificationMethod.PEER_LEAVE;\n    case 'peer-list':\n      return HMSNotificationMethod.PEER_LIST;\n    case 'on-track-add':\n      return HMSNotificationMethod.TRACK_METADATA_ADD;\n    case 'on-track-update':\n      return HMSNotificationMethod.TRACK_UPDATE;\n    case 'active-speakers':\n      return HMSNotificationMethod.ACTIVE_SPEAKERS;\n    case 'on-broadcast':\n      return HMSNotificationMethod.BROADCAST;\n    case 'on-role-change':\n      return HMSNotificationMethod.ROLE_CHANGE;\n    default:\n      HMSLogger.d(`method not supported - ${method}`);\n      return HMSNotificationMethod.UNSUPPORTED;\n  }\n};\n","// String enum to pass type as string for identification on receiver's end.\nexport enum HMSMessageType {\n  CHAT = 'chat',\n}\n\nexport const getMessageType = (type: string) => {\n  // Default type is CHAT\n  if (!type) {\n    return HMSMessageType.CHAT;\n  }\n\n  switch (type) {\n    case 'chat':\n      return HMSMessageType.CHAT;\n    default:\n      throw Error(`Unsupported message type=${type} received`);\n  }\n};\n","import HMSMediaStream from './HMSMediaStream';\nimport HMSTrack from '../tracks/HMSTrack';\nimport HMSTrackSettings from '../settings/HMSTrackSettings';\nimport HMSLocalAudioTrack from '../tracks/HMSLocalAudioTrack';\nimport HMSLocalVideoTrack from '../tracks/HMSLocalVideoTrack';\nimport HMSPublishConnection from '../../connection/publish';\nimport HMSVideoTrackSettings from '../settings/HMSVideoTrackSettings';\nimport HMSLogger from '../../utils/logger';\nimport { HMSAction } from '../../error/HMSAction';\nimport { BuildGetMediaError } from '../../error/HMSErrorFactory';\n\nconst TAG = 'HMSLocalStream';\n\n/** @internal */\nexport default class HMSLocalStream extends HMSMediaStream {\n  /** Connection set when publish is called for the first track */\n  private connection: HMSPublishConnection | null = null;\n\n  setConnection(connection: HMSPublishConnection) {\n    this.connection = connection;\n  }\n\n  static async getLocalScreen(settings: HMSVideoTrackSettings) {\n    const constraints = {\n      video: settings.toConstraints(),\n      audio: false,\n    } as MediaStreamConstraints;\n    let stream;\n    try {\n      // @ts-ignore [https://github.com/microsoft/TypeScript/issues/33232]\n      stream = (await navigator.mediaDevices.getDisplayMedia(constraints)) as MediaStream;\n    } catch (err) {\n      throw BuildGetMediaError(err, HMSAction.GetLocalScreen);\n    }\n\n    const local = new HMSLocalStream(stream);\n    const nativeTrack = stream.getVideoTracks()[0];\n    const track = new HMSLocalVideoTrack(local, nativeTrack, settings, 'screen');\n\n    HMSLogger.v(TAG, 'getLocalScreen', track);\n    return track;\n  }\n\n  static async getLocalTracks(settings: HMSTrackSettings) {\n    let stream;\n    try {\n      stream = await navigator.mediaDevices.getUserMedia({\n        audio: settings.audio != null ? settings.audio!.toConstraints() : false,\n        video: settings.video != null ? settings.video!.toConstraints() : false,\n      });\n    } catch (err) {\n      throw BuildGetMediaError(err, HMSAction.GetLocalScreen);\n    }\n\n    const local = new HMSLocalStream(stream);\n    const tracks: Array<HMSTrack> = [];\n    if (settings.audio != null) {\n      const nativeTrack = stream.getAudioTracks()[0];\n      const track = new HMSLocalAudioTrack(local, nativeTrack, settings.audio, 'regular');\n      tracks.push(track);\n    }\n\n    if (settings.video != null) {\n      const nativeTrack = stream.getVideoTracks()[0];\n      const track = new HMSLocalVideoTrack(local, nativeTrack, settings.video, 'regular');\n      tracks.push(track);\n    }\n\n    HMSLogger.v(TAG, 'getLocalTracks', tracks);\n    return tracks;\n  }\n\n  addTransceiver(track: HMSTrack) {\n    // TODO: Add support for simulcast\n    const transceiver = this.connection!.addTransceiver(track.nativeTrack, {\n      streams: [this.nativeStream],\n      direction: 'sendonly',\n      sendEncodings: undefined, // TODO\n    });\n    this.setPreferredCodec(transceiver, track.nativeTrack.kind);\n    return transceiver;\n  }\n\n  async setMaxBitrate(maxBitrate: number, track: HMSTrack): Promise<void> {\n    await this.connection?.setMaxBitrate(maxBitrate, track);\n  }\n\n  // @ts-ignore\n  setPreferredCodec(transceiver: RTCRtpTransceiver, kind: string) {\n    // TODO: Some browsers don't support setCodecPreferences, resort to SDPMunging?\n  }\n\n  async replaceTrack(track: HMSTrack, withTrack: MediaStreamTrack) {\n    const sender = this.connection!.getSenders().find((sender) => sender.track && sender.track!.id === track.trackId);\n\n    if (sender === undefined) throw Error(`No sender found for trackId=${track.trackId}`);\n    this.nativeStream.addTrack(withTrack);\n    this.nativeStream.removeTrack(track.nativeTrack);\n\n    sender.track!.stop(); // If the track is already stopped, this does not throw any error. ð\n\n    await sender.replaceTrack(withTrack);\n\n    track.nativeTrack = withTrack;\n  }\n\n  removeSender(track: HMSTrack) {\n    let removedSenderCount = 0;\n    this.connection!.getSenders().forEach((sender) => {\n      if (sender.track && sender.track.id === track.trackId) {\n        this.connection!.removeTrack(sender);\n        removedSenderCount += 1;\n\n        // Remove the local reference as well\n        const toRemoveLocalTrackIdx = this.tracks.indexOf(track);\n        if (toRemoveLocalTrackIdx !== -1) {\n          this.tracks.splice(toRemoveLocalTrackIdx, 1);\n        } else throw Error(`Cannot find ${track} in locally stored tracks`);\n      }\n    });\n    if (removedSenderCount !== 1) {\n      throw Error(`Removed ${removedSenderCount} sender's, expected to remove 1`);\n    }\n  }\n\n  trackUpdate(track: HMSTrack) {\n    this.connection?.trackUpdate(track);\n  }\n}\n","export enum TransportState {\n  Joined,\n  Disconnected,\n  Failed,\n  Reconnecting,\n}\n","import HMSMessage from '../../interfaces/message';\nimport { getMessageType, HMSMessageType } from './enums/HMSMessageType';\n\ninterface HMSMessageInit {\n  sender: string;\n  message: string;\n  type: string;\n  receiver?: string;\n  time?: Date | string;\n}\n\nexport default class Message implements HMSMessage {\n  sender: string;\n  receiver: string = '';\n  message: string;\n  time: Date;\n  type: HMSMessageType;\n\n  constructor({ sender, message, type, receiver, time }: HMSMessageInit) {\n    this.sender = sender;\n    this.message = message;\n    this.type = getMessageType(type);\n    if (receiver) {\n      this.receiver = receiver;\n    }\n    // If time is available, creating Message object for a received message.\n    if (time && time instanceof Date) {\n      this.time = time;\n    } else if (time && typeof time == 'string') {\n      // If a received message has time as string(when using JSON.stringify), convert and store as Date object.\n      this.time = new Date(time);\n    } else {\n      this.time = new Date();\n    }\n  }\n}\n","import HMSSpeaker from '../../interfaces/speaker';\n\nexport class Speaker implements HMSSpeaker {\n  peerId: string;\n  trackId: string;\n  audioLevel: number = 0;\n\n  constructor(peerId: string, trackId: string, audioLevel: number) {\n    this.peerId = peerId;\n    this.trackId = trackId;\n    this.audioLevel = audioLevel;\n  }\n}\n\nexport class SpeakerList {\n  speakers: HMSSpeaker[] = [];\n\n  constructor(speakerList: any) {\n    if (speakerList && speakerList.length > 0) {\n      this.speakers = speakerList.map((speaker: any) => new Speaker(speaker.peer_id, speaker.track_id, speaker.level));\n    }\n  }\n}\n","import HMSTrack from '../../media/tracks/HMSTrack';\nimport { Track } from '../../signal/ISignal';\nimport HMSLogger from '../../utils/logger';\nimport { HMSNotificationMethod } from './enums/HMSNotificationMethod';\nimport Message from './HMSMessage';\nimport { SpeakerList } from './HMSSpeaker';\n\nexport type HMSNotifications = Peer | PeerList | Message | TrackStateNotification | SpeakerList | undefined;\n\nexport interface TrackStateNotification {\n  tracks: Map<string, TrackState>;\n  peer: PeerNotificationInfo;\n}\n\nexport interface PeerNotificationInfo {\n  peer_id: string;\n  info: Info;\n}\n\nexport interface Info {\n  name: string;\n  data: string;\n  userId: string;\n}\n\nexport class TrackState implements Track {\n  mute: boolean;\n  type: 'audio' | 'video';\n  source: 'regular' | 'screen' | 'plugin';\n  description: string;\n  track_id: string;\n  stream_id: string;\n\n  constructor(track: HMSTrack | Track) {\n    this.type = track.type;\n    this.source = track.source || 'regular';\n    this.description = '';\n    if (track instanceof HMSTrack) {\n      this.mute = !track.enabled;\n      this.track_id = track.trackId;\n      this.stream_id = track.stream.id;\n    } else {\n      this.mute = track.mute;\n      this.track_id = track.track_id;\n      this.stream_id = track.stream_id;\n    }\n  }\n}\n\nexport class Peer {\n  peerId: string;\n  info: Info;\n  role: string;\n  tracks: TrackState[] = [];\n\n  constructor(params: any) {\n    this.peerId = params.peer_id;\n    this.info = {\n      name: params.info.name,\n      data: params.info.data,\n      userId: params.info.user_id,\n    };\n    this.role = params.role;\n    this.tracks = Object.values(params.tracks || {});\n  }\n}\n\nexport class PeerList {\n  peers: Peer[];\n\n  constructor(params: any) {\n    this.peers = Object.values(params.peers).map((peer) => new Peer(peer));\n  }\n}\n\nexport const getNotification = (method: HMSNotificationMethod, params: any) => {\n  switch (method) {\n    case HMSNotificationMethod.PEER_JOIN:\n      return new Peer(params);\n    case HMSNotificationMethod.PEER_LEAVE:\n      return new Peer(params);\n    case HMSNotificationMethod.PEER_LIST:\n      return new PeerList(params);\n    case HMSNotificationMethod.BROADCAST:\n      return new Message(params.info);\n    case HMSNotificationMethod.ACTIVE_SPEAKERS:\n      return new SpeakerList(params['speaker-list']);\n    case HMSNotificationMethod.ROLE_CHANGE:\n      return params as TrackStateNotification;\n    case HMSNotificationMethod.TRACK_METADATA_ADD:\n    case HMSNotificationMethod.TRACK_UPDATE: {\n      return params;\n    }\n    default:\n      HMSLogger.d(`method not implemented ${method}`);\n      return params;\n  }\n};\n","import ITransportObserver from './ITransportObserver';\nimport ITransport from './ITransport';\nimport HMSPublishConnection from '../connection/publish';\nimport HMSSubscribeConnection from '../connection/subscribe';\nimport InitService from '../signal/init';\nimport { ISignal } from '../signal/ISignal';\nimport { ISignalEventsObserver } from '../signal/ISignalEventsObserver';\nimport JsonRpcSignal from '../signal/jsonrpc';\nimport { HMSConnectionRole, HMSTrickle } from '../connection/model';\nimport { IPublishConnectionObserver } from '../connection/publish/IPublishConnectionObserver';\nimport ISubscribeConnectionObserver from '../connection/subscribe/ISubscribeConnectionObserver';\nimport HMSTrack from '../media/tracks/HMSTrack';\nimport HMSException, { HMSExceptionBuilder } from '../error/HMSException';\nimport { PromiseCallbacks } from '../utils/promise';\nimport { RENEGOTIATION_CALLBACK_ID } from '../utils/constants';\nimport HMSLocalStream from '../media/streams/HMSLocalStream';\nimport HMSTrackSettings from '../media/settings/HMSTrackSettings';\nimport HMSLogger from '../utils/logger';\nimport HMSVideoTrackSettings from '../media/settings/HMSVideoTrackSettings';\nimport HMSMessage from '../interfaces/message';\nimport { TrackState } from '../sdk/models/HMSNotifications';\nimport HMSErrors from '../error/HMSErrors';\nimport { TransportState } from './TransportState';\nimport { HMSAction } from '../error/HMSAction';\n\nconst TAG = '[HMSTransport]:';\ninterface CallbackTriple {\n  promise: PromiseCallbacks<boolean>;\n  action: HMSAction;\n  extra: any;\n}\n\nexport default class HMSTransport implements ITransport {\n  private state: TransportState = TransportState.Disconnected;\n  private tracks: Map<string, TrackState> = new Map();\n  private readonly observer: ITransportObserver;\n  private publishConnection: HMSPublishConnection | null = null;\n  private subscribeConnection: HMSSubscribeConnection | null = null;\n\n  /**\n   * Map of callbacks used to wait for an event to fire.\n   * Used here for:\n   *  1. publish/unpublish waits for [IPublishConnectionObserver.onRenegotiationNeeded] to complete\n   */\n  private readonly callbacks = new Map<string, CallbackTriple>();\n\n  private signalObserver: ISignalEventsObserver = {\n    onOffer: async (jsep: RTCSessionDescriptionInit) => {\n      await this.subscribeConnection!.setRemoteDescription(jsep);\n      for (const candidate of this.subscribeConnection!.candidates) {\n        await this.subscribeConnection!.addIceCandidate(candidate);\n      }\n      this.subscribeConnection!.candidates.length = 0;\n      const answer = await this.subscribeConnection!.createAnswer();\n      await this.subscribeConnection!.setLocalDescription(answer);\n      this.signal.answer(answer);\n    },\n    onTrickle: async (trickle: HMSTrickle) => {\n      const connection =\n        trickle.target === HMSConnectionRole.Publish ? this.publishConnection! : this.subscribeConnection!;\n      if (connection.remoteDescription === null) {\n        // ICE candidates can't be added without any remote session description\n        connection.candidates.push(trickle.candidate);\n      } else {\n        await connection.addIceCandidate(trickle.candidate);\n      }\n    },\n    onNotification: (message: Object) => this.observer.onNotification(message),\n    onFailure: (exception: HMSException) => {\n      // TODO: Init the reconnecting logic\n      this.observer.onFailure(exception);\n    },\n  };\n\n  private readonly signal: ISignal = new JsonRpcSignal(this.signalObserver);\n\n  private publishConnectionObserver: IPublishConnectionObserver = {\n    onRenegotiationNeeded: async () => {\n      HMSLogger.d(TAG, `â³ [role=PUBLISH] onRenegotiationNeeded START`, this.tracks);\n      const callback = this.callbacks.get(RENEGOTIATION_CALLBACK_ID);\n      this.callbacks.delete(RENEGOTIATION_CALLBACK_ID);\n\n      try {\n        const offer = await this.publishConnection!.createOffer();\n        await this.publishConnection!.setLocalDescription(offer);\n        const answer = await this.signal.offer(offer, this.tracks);\n        await this.publishConnection!.setRemoteDescription(answer);\n        callback!.promise.resolve(true);\n        HMSLogger.d(TAG, `[role=PUBLISH] onRenegotiationNeeded DONE â`);\n      } catch (err) {\n        let ex: HMSException;\n        if (err instanceof HMSException) {\n          ex = err;\n        } else {\n          ex = new HMSExceptionBuilder(HMSErrors.PeerConnectionFailed)\n            .action(callback!.action)\n            .errorInfo(err.message)\n            .build();\n        }\n\n        callback!.promise.reject(ex);\n        HMSLogger.d(TAG, `[role=PUBLISH] onRenegotiationNeeded FAILED â`);\n      }\n    },\n\n    onIceConnectionChange: (newState: RTCIceConnectionState) => {\n      if (newState === 'failed') {\n        this.handleIceConnectionFailure(HMSConnectionRole.Publish);\n      }\n    },\n  };\n\n  private subscribeConnectionObserver: ISubscribeConnectionObserver = {\n    onApiChannelMessage: (message: string) => {\n      this.observer.onNotification(JSON.parse(message));\n    },\n\n    onTrackAdd: (track: HMSTrack) => {\n      HMSLogger.d(TAG, '[Subscribe] onTrackAdd', track);\n      this.observer.onTrackAdd(track);\n    },\n\n    onTrackRemove: (track: HMSTrack) => {\n      HMSLogger.d(TAG, '[Subscribe] onTrackRemove', track);\n      this.observer.onTrackRemove(track);\n    },\n\n    onIceConnectionChange: (newState: RTCIceConnectionState) => {\n      if (newState === 'failed') {\n        this.handleIceConnectionFailure(HMSConnectionRole.Subscribe);\n      }\n    },\n  };\n\n  private handleIceConnectionFailure(role: HMSConnectionRole) {\n    // TODO: Should we initiate an ice-restart?\n    // TODO: Should we close both peer-connections or just one?\n\n    const ex = new HMSExceptionBuilder(HMSErrors.PeerConnectionFailed)\n      .errorInfo(`[role=${role}] Ice connection state FAILED`)\n      .build();\n\n    this.state = TransportState.Failed;\n    this.observer.onFailure(ex);\n  }\n\n  constructor(observer: ITransportObserver) {\n    this.observer = observer;\n  }\n\n  async getLocalScreen(settings: HMSVideoTrackSettings): Promise<HMSTrack> {\n    return await HMSLocalStream.getLocalScreen(settings);\n  }\n\n  async getLocalTracks(settings: HMSTrackSettings): Promise<Array<HMSTrack>> {\n    return await HMSLocalStream.getLocalTracks(settings);\n  }\n\n  async join(\n    authToken: string,\n    peerId: string,\n    customData: any,\n    initEndpoint?: string,\n    autoSubscribeVideo: boolean = true,\n  ): Promise<void> {\n    if (this.state !== TransportState.Disconnected) {\n      throw new HMSExceptionBuilder(HMSErrors.AlreadyJoined).action(HMSAction.Join).build();\n    }\n    const config = await InitService.fetchInitConfig(authToken, initEndpoint);\n\n    HMSLogger.d(TAG, 'â³ join: connecting to ws endpoint', config.endpoint);\n    await this.signal.open(`${config.endpoint}?peer=${peerId}&token=${authToken}`);\n    HMSLogger.d(TAG, 'â join: connected to ws endpoint');\n\n    HMSLogger.d(TAG, customData);\n\n    this.publishConnection = new HMSPublishConnection(\n      this.signal,\n      config.rtcConfiguration,\n      this.publishConnectionObserver,\n      this,\n    );\n\n    this.subscribeConnection = new HMSSubscribeConnection(\n      this.signal,\n      config.rtcConfiguration,\n      this.subscribeConnectionObserver,\n    );\n\n    HMSLogger.d(TAG, 'â³ join: Negotiating over PUBLISH connection');\n    const offer = await this.publishConnection.createOffer();\n    await this.publishConnection.setLocalDescription(offer);\n    const answer = await this.signal.join(customData.name, peerId, offer, !autoSubscribeVideo);\n    await this.publishConnection.setRemoteDescription(answer);\n    for (const candidate of this.publishConnection.candidates) {\n      await this.publishConnection.addIceCandidate(candidate);\n    }\n    this.publishConnection.initAfterJoin();\n    HMSLogger.d(TAG, 'â join: Negotiated over PUBLISH connection');\n\n    // TODO: Handle exceptions raised - wrap them in HMSException\n    HMSLogger.d(TAG, 'â join: successful');\n  }\n\n  async leave(): Promise<void> {\n    await this.publishConnection!.close();\n    await this.subscribeConnection!.close();\n    this.signal.leave();\n    await this.signal.close();\n  }\n\n  private async publishTrack(track: HMSTrack): Promise<void> {\n    HMSLogger.d(TAG, `â³ publishTrack: trackId=${track.trackId}`, track);\n    this.tracks.set(track.trackId, new TrackState(track));\n    const p = new Promise<boolean>((resolve, reject) => {\n      this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n        promise: { resolve, reject },\n        action: HMSAction.Publish,\n        extra: {},\n      });\n    });\n    const stream = track.stream as HMSLocalStream;\n    stream.setConnection(this.publishConnection!);\n    stream.addTransceiver(track);\n    await p;\n\n    // @ts-ignore\n    const maxBitrate = track.settings.maxBitrate;\n    await stream\n      .setMaxBitrate(maxBitrate, track)\n      .then(() => {\n        HMSLogger.i(TAG, `Setting maxBitrate for ${track.source} ${track.type} to ${maxBitrate} kpbs`);\n      })\n      .catch((error) => HMSLogger.e(TAG, 'Failed setting maxBitrate', error));\n\n    HMSLogger.d(TAG, `â publishTrack: trackId=${track.trackId}`, this.callbacks);\n  }\n\n  private async unpublishTrack(track: HMSTrack): Promise<void> {\n    HMSLogger.d(TAG, `â³ unpublishTrack: trackId=${track.trackId}`, track);\n    this.tracks.delete(track.trackId);\n    const p = new Promise<boolean>((resolve, reject) => {\n      this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n        promise: { resolve, reject },\n        action: HMSAction.Unpublish,\n        extra: {},\n      });\n    });\n    const stream = track.stream as HMSLocalStream;\n    stream.removeSender(track);\n    await p;\n    HMSLogger.d(TAG, `â unpublishTrack: trackId=${track.trackId}`, this.callbacks);\n  }\n\n  async publish(tracks: Array<HMSTrack>): Promise<void> {\n    for (const track of tracks) {\n      await this.publishTrack(track);\n    }\n  }\n\n  async unpublish(tracks: Array<HMSTrack>): Promise<void> {\n    for (const track of tracks) {\n      await this.unpublishTrack(track);\n    }\n  }\n\n  sendMessage(message: HMSMessage) {\n    this.signal.broadcast(message);\n  }\n\n  trackUpdate(track: HMSTrack) {\n    const currentTrackStates = Array.from(this.tracks.values());\n    const originalTrackState = currentTrackStates.find(\n      (trackState) => track.type === trackState.type && track.source === trackState.source,\n    );\n    if (originalTrackState) {\n      const newTrackState = new TrackState({\n        ...originalTrackState,\n        mute: !track.enabled,\n      });\n      this.tracks.set(originalTrackState.track_id, newTrackState);\n      HMSLogger.d(TAG, 'Track Update', this.tracks, track);\n      this.signal.trackUpdate(new Map([[originalTrackState.track_id, newTrackState]]));\n    }\n  }\n}\n","import HMSException from '../error/HMSException';\nimport HMSTrack from '../media/tracks/HMSTrack';\nimport HMSPeer from './hms-peer';\nimport HMSMessage from './message';\nimport HMSRoom from './room';\nimport HMSSpeaker from './speaker';\n\nexport enum HMSRoomUpdate {\n  PEER_ADDED,\n  PEER_REMOVED,\n  PEER_KNOCKED,\n  ROOM_TYPE_CHANGED,\n  METADATA_UPDATED,\n  SCREENSHARE_STARTED,\n  SCREENSHARE_STOPPED,\n  DEFAULT_UPDATE,\n}\n\nexport enum HMSPeerUpdate {\n  PEER_JOINED,\n  PEER_LEFT,\n  AUDIO_TOGGLED,\n  VIDEO_TOGGLED,\n  BECAME_DOMINANT_SPEAKER,\n  RESIGNED_DOMINANT_SPEAKER,\n  STARTED_SPEAKING,\n  STOPPED_SPEAKING,\n}\n\nexport enum HMSTrackUpdate {\n  TRACK_ADDED,\n  TRACK_REMOVED,\n  TRACK_MUTED,\n  TRACK_UNMUTED,\n  TRACK_DESCRIPTION_CHANGED,\n}\n\nexport interface HMSAudioListener {\n  onAudioLevelUpdate(speakers: HMSSpeaker[]): void;\n}\n\nexport default interface HMSUpdateListener {\n  onJoin(room: HMSRoom): void;\n  onRoomUpdate(type: HMSRoomUpdate, room: HMSRoom): void;\n  onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer | null): void;\n  onTrackUpdate(type: HMSTrackUpdate, track: HMSTrack, peer: HMSPeer): void;\n  onMessageReceived(message: HMSMessage): void;\n  onError(error: HMSException): void;\n}\n","import HMSPeer from '../interfaces/hms-peer';\nimport HMSTrack from '../media/tracks/HMSTrack';\n\ntype HMSPeerInit = {\n  peerId: string;\n  name: string;\n  isLocal: boolean;\n  customerDescription: string;\n  role?: string;\n};\n\nexport default class Peer implements HMSPeer {\n  peerId: string;\n  isLocal: boolean;\n  name: string;\n  customerDescription: string = '';\n  videoTrack?: HMSTrack | null;\n  audioTrack?: HMSTrack | null;\n  auxiliaryTracks: HMSTrack[] = [];\n  role?: string = '';\n\n  constructor({ peerId, name, isLocal, role, customerDescription }: HMSPeerInit) {\n    this.name = name;\n    this.peerId = peerId;\n    this.isLocal = isLocal;\n    this.role = role;\n    this.customerDescription = customerDescription;\n  }\n}\n","import HMSTrack from '../media/tracks/HMSTrack';\nimport { HMSTrackType } from '../media/tracks';\nimport Peer from '../peer';\nimport { HMSNotificationMethod } from './models/enums/HMSNotificationMethod';\nimport {\n  Peer as PeerNotification,\n  HMSNotifications,\n  PeerList,\n  TrackStateNotification,\n  TrackState,\n} from './models/HMSNotifications';\nimport HMSLogger from '../utils/logger';\nimport HMSPeer from '../interfaces/hms-peer';\nimport HMSUpdateListener, { HMSAudioListener, HMSPeerUpdate, HMSTrackUpdate } from '../interfaces/update-listener';\nimport { SpeakerList } from './models/HMSSpeaker';\n\ninterface TrackStateEntry {\n  peerId: string;\n  trackInfo: TrackState;\n}\n\nexport default class NotificationManager extends EventTarget {\n  hmsPeerList: Map<string, HMSPeer> = new Map();\n  localPeer!: HMSPeer | null;\n\n  private TAG: string = '[Notification Manager]:';\n  private tracksToProcess: Map<string, HMSTrack> = new Map();\n  private trackStateMap: Map<string, TrackStateEntry> = new Map();\n  private listener!: HMSUpdateListener;\n  private audioListener: HMSAudioListener | null = null;\n\n  handleNotification(\n    method: HMSNotificationMethod,\n    notification: HMSNotifications,\n    listener: HMSUpdateListener,\n    audioListener: HMSAudioListener | null,\n  ) {\n    this.listener = listener;\n    this.audioListener = audioListener;\n    switch (method) {\n      case HMSNotificationMethod.PEER_JOIN: {\n        const peer = notification as PeerNotification;\n        HMSLogger.d(this.TAG, `PEER_JOIN event`, peer, notification);\n        this.handlePeerJoin(peer);\n        break;\n      }\n      case HMSNotificationMethod.PEER_LEAVE: {\n        const peer = notification as PeerNotification;\n        HMSLogger.d(this.TAG, `PEER_LEAVE event`, peer);\n        this.handlePeerLeave(peer);\n        break;\n      }\n      case HMSNotificationMethod.PEER_LIST: {\n        const peerList = notification as PeerList;\n        HMSLogger.d(this.TAG, `PEER_LIST event`, peerList);\n        this.handlePeerList(peerList);\n        break;\n      }\n      case HMSNotificationMethod.TRACK_METADATA_ADD: {\n        this.handleTrackMetadataAdd(notification as TrackStateNotification);\n        break;\n      }\n      case HMSNotificationMethod.TRACK_UPDATE: {\n        this.handleTrackUpdate(notification as TrackStateNotification);\n        break;\n      }\n      case HMSNotificationMethod.ROLE_CHANGE: {\n        this.handleRoleChange(notification as TrackStateNotification);\n        break;\n      }\n      case HMSNotificationMethod.ACTIVE_SPEAKERS:\n        this.handleActiveSpeakers(notification as SpeakerList);\n        break;\n      default:\n        return;\n    }\n  }\n\n  handleRoleChange(params: TrackStateNotification) {\n    // @DISCUSS: Make everything event based instead?\n    this.dispatchEvent(new CustomEvent('role-change', { detail: { params } }));\n  }\n\n  handleTrackMetadataAdd(params: TrackStateNotification) {\n    HMSLogger.d(this.TAG, `TRACK_METADATA_ADD`, params);\n\n    for (const [trackId, trackEntry] of Object.entries(params.tracks)) {\n      this.trackStateMap.set(trackId, {\n        peerId: params.peer.peer_id,\n        trackInfo: trackEntry,\n      });\n    }\n\n    this.processPendingTracks();\n  }\n\n  private processPendingTracks() {\n    const tracksCopy = new Map(this.tracksToProcess);\n\n    tracksCopy.forEach((track) => {\n      const state = this.trackStateMap.get(track.trackId);\n      if (!state) return;\n\n      const hmsPeer = this.hmsPeerList.get(state.peerId);\n      if (!hmsPeer) return;\n\n      track.source = state.trackInfo.source;\n      track.setEnabled(!state.trackInfo.mute);\n\n      switch (track.type) {\n        case HMSTrackType.AUDIO:\n          if (!hmsPeer.audioTrack) {\n            hmsPeer.audioTrack = track;\n          }\n          // @DISCUSS: Do we have auxilliary audio tracks too?\n          break;\n\n        case HMSTrackType.VIDEO:\n          if (!hmsPeer.videoTrack && track.source === 'regular') {\n            hmsPeer.videoTrack = track;\n          } else {\n            hmsPeer.auxiliaryTracks.push(track);\n          }\n      }\n\n      track.type === HMSTrackType.AUDIO && this.dispatchEvent(new CustomEvent('track-added', { detail: track }));\n      this.listener.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, hmsPeer);\n      this.tracksToProcess.delete(track.trackId);\n    });\n  }\n\n  /**\n   * Sets the tracks to peer and returns the peer\n   */\n  handleOnTrackAdd = (track: HMSTrack) => {\n    HMSLogger.d(this.TAG, `ONTRACKADD`, track);\n    this.tracksToProcess.set(track.trackId, track);\n    this.processPendingTracks();\n  };\n\n  /**\n   * Sets the track of corresponding peer to null and returns the peer\n   */\n  handleOnTrackRemove = (track: HMSTrack) => {\n    HMSLogger.d(this.TAG, `ONTRACKREMOVE`, track);\n    const trackStateEntry = this.trackStateMap.get(track.trackId);\n\n    if (!trackStateEntry) return;\n\n    const hmsPeer = this.hmsPeerList.get(trackStateEntry.peerId);\n\n    if (hmsPeer) {\n      switch (track.type) {\n        case HMSTrackType.AUDIO:\n          hmsPeer.audioTrack = null;\n          break;\n        case HMSTrackType.VIDEO: {\n          const screenShareTrackIndex = hmsPeer.auxiliaryTracks.indexOf(track);\n\n          if (screenShareTrackIndex > -1) {\n            // @TODO: change this based on source\n            hmsPeer.auxiliaryTracks.splice(screenShareTrackIndex, 1);\n          } else {\n            hmsPeer.videoTrack = null;\n          }\n        }\n      }\n      track.type === HMSTrackType.AUDIO && this.dispatchEvent(new CustomEvent('track-removed', { detail: track }));\n      this.listener.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);\n    }\n  };\n\n  handleTrackUpdate = (params: TrackStateNotification) => {\n    HMSLogger.d(this.TAG, `TRACK_UPDATE`, params);\n\n    const hmsPeer = this.hmsPeerList.get(params.peer.peer_id);\n    if (!hmsPeer) return;\n\n    for (const [trackId, trackEntry] of Object.entries(params.tracks)) {\n      const currentTrackStateInfo = Object.assign({}, this.trackStateMap.get(trackId)?.trackInfo);\n\n      const track = this.getPeerTrackByTrackId(hmsPeer.peerId, trackId);\n\n      this.trackStateMap.set(trackId, {\n        peerId: params.peer.peer_id,\n        trackInfo: { ...currentTrackStateInfo, ...trackEntry },\n      });\n\n      // TRACK_UPDATE came before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.\n      if (!track || this.tracksToProcess.has(trackId)) {\n        this.processPendingTracks();\n      } else {\n        track.setEnabled(!trackEntry.mute);\n\n        if (currentTrackStateInfo.mute !== trackEntry.mute) {\n          if (trackEntry.mute) {\n            this.listener.onTrackUpdate(HMSTrackUpdate.TRACK_MUTED, track, hmsPeer);\n          } else {\n            this.listener.onTrackUpdate(HMSTrackUpdate.TRACK_UNMUTED, track, hmsPeer);\n          }\n        } else if (currentTrackStateInfo.description !== trackEntry.description) {\n          this.listener.onTrackUpdate(HMSTrackUpdate.TRACK_DESCRIPTION_CHANGED, track, hmsPeer);\n        }\n      }\n    }\n  };\n\n  cleanUp = () => {\n    this.hmsPeerList.clear();\n  };\n\n  findPeerByPeerId = (peerId: string) => {\n    if (this.localPeer?.peerId === peerId) {\n      return this.localPeer;\n    }\n\n    return this.hmsPeerList.get(peerId);\n  };\n\n  private handlePeerJoin = (peer: PeerNotification) => {\n    const hmsPeer = new Peer({\n      peerId: peer.peerId,\n      name: peer.info.name,\n      isLocal: false,\n      customerDescription: '',\n      role: peer.role,\n    });\n\n    this.hmsPeerList.set(peer.peerId, hmsPeer);\n    HMSLogger.d(this.TAG, `adding to the peerList`, hmsPeer);\n\n    peer.tracks.forEach((track) => {\n      this.trackStateMap.set(track.track_id, {\n        peerId: peer.peerId,\n        trackInfo: track,\n      });\n    });\n\n    this.processPendingTracks();\n  };\n\n  private handlePeerLeave = (peer: PeerNotification) => {\n    this.hmsPeerList.delete(peer.peerId);\n  };\n\n  private handlePeerList = (peerList: PeerList) => {\n    const peers = peerList.peers;\n    peers?.forEach((peer) => this.handlePeerJoin(peer));\n  };\n\n  /**\n   * @param speakerList List of speakers[peer_id, level] sorted by level in descending order.\n   */\n  handleActiveSpeakers(speakerList: SpeakerList) {\n    const speakers = speakerList.speakers;\n    this.audioListener?.onAudioLevelUpdate(speakers);\n    const dominantSpeaker = speakers[0];\n    if (dominantSpeaker) {\n      const dominantSpeakerPeer = this.findPeerByPeerId(dominantSpeaker.peerId);\n      this.listener.onPeerUpdate(HMSPeerUpdate.BECAME_DOMINANT_SPEAKER, dominantSpeakerPeer!);\n    } else {\n      this.listener.onPeerUpdate(HMSPeerUpdate.RESIGNED_DOMINANT_SPEAKER, null);\n    }\n  }\n\n  private getPeerTrackByTrackId(peerId: string, trackId: string) {\n    const peer = this.findPeerByPeerId(peerId);\n\n    if (peer?.audioTrack?.trackId === trackId) {\n      return peer.audioTrack;\n    } else if (peer?.videoTrack?.trackId === trackId) {\n      return peer.videoTrack;\n    } else {\n      return peer?.auxiliaryTracks.find((track) => track.trackId === trackId);\n    }\n  }\n}\n","import HMSVideoTrackSettings, { HMSVideoTrackSettingsBuilder } from './HMSVideoTrackSettings';\nimport HMSAudioTrackSettings, { HMSAudioTrackSettingsBuilder } from './HMSAudioTrackSettings';\nimport { HMSExceptionBuilder } from '../../error/HMSException';\nimport HMSErrors from '../../error/HMSErrors';\n\nexport class HMSTrackSettingsBuilder {\n  private _video: HMSVideoTrackSettings | null = new HMSVideoTrackSettingsBuilder().build();\n  private _audio: HMSAudioTrackSettings | null = new HMSAudioTrackSettingsBuilder().build();\n  private _simulcast = false;\n\n  video(video: HMSVideoTrackSettings | null) {\n    this._video = video;\n    return this;\n  }\n\n  audio(audio: HMSAudioTrackSettings | null) {\n    this._audio = audio;\n    return this;\n  }\n\n  simulcast(enabled: boolean) {\n    this._simulcast = enabled;\n    return this;\n  }\n\n  build() {\n    if (this._audio === null && this._video === null) {\n      throw new HMSExceptionBuilder(HMSErrors.NothingToReturn).build();\n    }\n\n    if (this._video === null && this._simulcast) {\n      throw Error('Cannot enable simulcast when no video settings are provided');\n    }\n\n    return new HMSTrackSettings(this._video, this._audio, this._simulcast);\n  }\n}\n\nexport default class HMSTrackSettings {\n  readonly video: HMSVideoTrackSettings | null;\n  readonly audio: HMSAudioTrackSettings | null;\n  readonly simulcast: boolean;\n\n  constructor(video: HMSVideoTrackSettings | null, audio: HMSAudioTrackSettings | null, simulcast: boolean) {\n    this.video = video;\n    this.audio = audio;\n    this.simulcast = simulcast;\n  }\n}\n","import Peer from '../../peer';\nimport HMSRoom, { HMSRoomType } from '../../interfaces/room';\n\nexport default class Room implements HMSRoom {\n  id: string;\n  name: string;\n  peers: Peer[];\n  shareableLink!: string;\n  type!: HMSRoomType;\n  hasWaitingRoom!: boolean;\n\n  constructor(id: string, name: string, peers: Peer[]) {\n    this.id = id;\n    this.name = name;\n    this.peers = peers;\n  }\n}\n","import { v4 as uuid } from 'uuid';\nimport HMSAudioTrack from '../media/tracks/HMSAudioTrack';\nimport NotificationManager from '../sdk/NotificationManager';\n\nconst SILENT_AUDIO_URL = 'https://res.cloudinary.com/dlzh3j8em/video/upload/v1619210717/silence_xko7fm.mp3';\n\nexport default class HMSAudioSinkManager {\n  private audioSink: HTMLElement;\n  private notificationManager: NotificationManager;\n\n  constructor(notificationManager: NotificationManager, elementId?: string) {\n    const audioSink = document.createElement('div');\n    audioSink.id = `HMS-SDK-audio-sink-${uuid()}`;\n    const userElement = elementId && document.getElementById(elementId);\n    const audioSinkParent = userElement || document.body;\n    audioSinkParent.append(audioSink);\n\n    this.audioSink = audioSink;\n    this.addSilentAudio();\n    this.notificationManager = notificationManager;\n    this.notificationManager.addEventListener('track-added', this.handleTrackAdd as EventListener);\n    this.notificationManager.addEventListener('track-removed', this.handleTrackRemove as EventListener);\n  }\n\n  cleanUp() {\n    this.notificationManager.removeEventListener('track-added', this.handleTrackAdd as EventListener);\n    this.notificationManager.removeEventListener('track-removed', this.handleTrackRemove as EventListener);\n  }\n\n  private addSilentAudio() {\n    const silentAudio = document.createElement('audio');\n    silentAudio.autoplay = true;\n    silentAudio.style.display = 'none';\n    silentAudio.id = `HMS-SDK-silent-audio-track-${uuid()}`;\n    silentAudio.src = SILENT_AUDIO_URL;\n\n    this.audioSink.append(silentAudio);\n  }\n\n  private handleTrackAdd = (event: CustomEvent<HMSAudioTrack>) => {\n    const track = event.detail;\n    const audioEl = document.createElement('audio');\n    audioEl.autoplay = true;\n    audioEl.style.display = 'none';\n    audioEl.id = track.trackId;\n    audioEl.srcObject = new MediaStream([track.nativeTrack]);\n\n    this.audioSink.append(audioEl);\n  };\n\n  private handleTrackRemove = (event: CustomEvent<HMSAudioTrack>) => {\n    const track = event.detail;\n    document.getElementById(track.trackId)?.remove();\n  };\n}\n","import { HMSAction } from '../error/HMSAction';\nimport { BuildGetMediaError } from '../error/HMSErrorFactory';\n\nexport async function getLocalStream(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n    return stream;\n  } catch (err) {\n    throw BuildGetMediaError(err, HMSAction.GetLocalStream);\n  }\n}\n\nexport async function getLocalScreen(constraints: MediaStreamConstraints['video']): Promise<MediaStream> {\n  try {\n    // @ts-ignore [https://github.com/microsoft/TypeScript/issues/33232]\n    const stream = await navigator.mediaDevices.getDisplayMedia({ video: constraints, audio: false });\n    return stream;\n  } catch (err) {\n    throw BuildGetMediaError(err, HMSAction.GetLocalScreen);\n  }\n}\n\ninterface MediaDeviceGroups {\n  audioinput: MediaDeviceInfo[];\n  audiooutput: MediaDeviceInfo[];\n  videoinput: MediaDeviceInfo[];\n}\n\nexport async function getLocalDevices(): Promise<MediaDeviceGroups> {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const deviceGroups: MediaDeviceGroups = {\n      audioinput: [],\n      audiooutput: [],\n      videoinput: [],\n    };\n    devices.forEach((device) => deviceGroups[device.kind].push(device));\n    return deviceGroups;\n  } catch (err) {\n    throw BuildGetMediaError(err, HMSAction.GetLocalDevices);\n  }\n}\n","import HMSConfig from '../interfaces/config';\nimport InitialSettings from '../interfaces/settings';\nimport HMSInterface, { HMSAnalyticsLevel } from '../interfaces/hms';\nimport HMSPeer from '../interfaces/hms-peer';\nimport HMSTransport from '../transport';\nimport ITransportObserver from '../transport/ITransportObserver';\nimport HMSUpdateListener, { HMSAudioListener, HMSPeerUpdate, HMSTrackUpdate } from '../interfaces/update-listener';\nimport HMSLogger, { HMSLogLevel } from '../utils/logger';\nimport decodeJWT from '../utils/jwt';\nimport { getNotificationMethod, HMSNotificationMethod } from './models/enums/HMSNotificationMethod';\nimport { getNotification, HMSNotifications, Peer as PeerNotification } from './models/HMSNotifications';\nimport NotificationManager from './NotificationManager';\nimport HMSTrack from '../media/tracks/HMSTrack';\nimport { HMSTrackType } from '../media/tracks';\nimport HMSException from '../error/HMSException';\nimport { HMSTrackSettingsBuilder } from '../media/settings/HMSTrackSettings';\nimport HMSRoom from './models/HMSRoom';\nimport { v4 as uuidv4 } from 'uuid';\nimport Peer from '../peer';\nimport Message from './models/HMSMessage';\nimport HMSVideoTrackSettings, { HMSVideoTrackSettingsBuilder } from '../media/settings/HMSVideoTrackSettings';\nimport HMSAudioTrackSettings, { HMSAudioTrackSettingsBuilder } from '../media/settings/HMSAudioTrackSettings';\nimport HMSAudioSinkManager from '../audio-sink-manager';\n\nexport class HMSSdk implements HMSInterface {\n  logLevel: HMSLogLevel = HMSLogLevel.INFO;\n  analyticsLevel: HMSAnalyticsLevel = HMSAnalyticsLevel.OFF;\n  transport!: HMSTransport | null;\n  roomId!: string | null;\n  localPeer!: HMSPeer | null;\n\n  private TAG: string = '[HMSSdk]:';\n  private notificationManager: NotificationManager = new NotificationManager();\n  private listener!: HMSUpdateListener | null;\n  private audioListener: HMSAudioListener | null = null;\n  private audioSinkManager!: HMSAudioSinkManager;\n  private hmsRoom?: HMSRoom | null;\n  private published: boolean = false;\n  private publishParams: any = null;\n\n  private observer: ITransportObserver = {\n    onNotification: (message: any) => {\n      const method = getNotificationMethod(message.method);\n      const notification = getNotification(method, message.params);\n      // @TODO: Notification manager needs to be refactored. The current implementation is not manageable\n      // this will pollute logs\n      if (method !== HMSNotificationMethod.ACTIVE_SPEAKERS) {\n        HMSLogger.d(this.TAG, `onNotification: message=${message}`);\n      }\n      this.notificationManager.handleNotification(method, notification, this.listener!, this.audioListener);\n      this.onNotificationHandled(method, notification);\n    },\n\n    onTrackAdd: (track: HMSTrack) => {\n      this.notificationManager.handleOnTrackAdd(track);\n    },\n\n    onTrackRemove: (track: HMSTrack) => {\n      this.notificationManager.handleOnTrackRemove(track);\n    },\n\n    onFailure: (exception: HMSException) => {\n      this.listener?.onError(exception);\n    },\n  };\n\n  join(config: HMSConfig, listener: HMSUpdateListener) {\n    this.notificationManager.addEventListener('role-change', (e: any) => {\n      this.publishParams = e.detail.params.role.publishParams;\n    });\n    this.transport = new HMSTransport(this.observer);\n    this.listener = listener;\n    this.audioSinkManager = new HMSAudioSinkManager(this.notificationManager, config.audioSinkElementId);\n    const { roomId, role } = decodeJWT(config.authToken);\n\n    const peerId = uuidv4();\n\n    this.localPeer = new Peer({\n      peerId,\n      name: config.userName,\n      isLocal: true,\n      role,\n      customerDescription: config.metaData,\n    });\n    this.notificationManager.localPeer = this.localPeer;\n\n    HMSLogger.d(this.TAG, `â³ Joining room ${roomId}`);\n\n    this.transport\n      .join(\n        config.authToken,\n        this.localPeer.peerId,\n        { name: config.userName },\n        config.initEndpoint,\n        config.autoVideoSubscribe,\n      )\n      .then(() => {\n        HMSLogger.d(this.TAG, `â Joined room ${roomId}`);\n        this.roomId = roomId;\n        if (!this.published) {\n          this.publish(config.settings);\n        }\n        this.listener?.onJoin(this.createRoom());\n      });\n  }\n\n  private cleanUp() {\n    this.audioSinkManager.cleanUp();\n    this.notificationManager.cleanUp();\n\n    this.published = false;\n    this.localPeer = null;\n    this.roomId = null;\n    this.hmsRoom = null;\n    this.transport = null;\n    this.listener = null;\n  }\n\n  async leave() {\n    if (this.roomId) {\n      const roomId = this.roomId;\n      HMSLogger.d(this.TAG, `â³ Leaving room ${roomId}`);\n      this.localPeer?.audioTrack?.nativeTrack.stop();\n      this.localPeer?.videoTrack?.nativeTrack.stop();\n      await this.transport?.leave();\n      this.cleanUp();\n      HMSLogger.d(this.TAG, `â Left room ${roomId}`);\n    }\n  }\n\n  getLocalPeer(): HMSPeer {\n    return this.localPeer!;\n  }\n\n  getPeers(): HMSPeer[] {\n    const remotePeers = Array.from(this.notificationManager.hmsPeerList, (x) => x[1]);\n    const peers = this.localPeer ? [...remotePeers, this.getLocalPeer()] : remotePeers;\n    HMSLogger.d(this.TAG, `Got peers`, peers);\n    return peers;\n  }\n\n  sendMessage(type: string, message: string, receiver?: string) {\n    const hmsMessage = new Message({ sender: this.localPeer!.peerId, type, message, receiver });\n    HMSLogger.d(this.TAG, 'Sending Message:: ', hmsMessage);\n    this.transport!.sendMessage(hmsMessage);\n    return hmsMessage;\n  }\n\n  async startScreenShare(onStop: () => void) {\n    const { screen } = this.publishParams;\n\n    if ((this.localPeer?.auxiliaryTracks?.length || 0) > 0) {\n      throw Error('Cannot share multiple screens');\n    }\n\n    const track = await this.transport!.getLocalScreen(\n      new HMSVideoTrackSettingsBuilder()\n        .maxBitrate(screen.bitRate)\n        .codec(screen.codec)\n        .maxFramerate(screen.frameRate)\n        .setWidth(screen.width)\n        .setHeight(screen.height)\n        .build(),\n    );\n    track.nativeTrack.onended = () => {\n      this.stopEndedScreenshare(onStop);\n    };\n    await this.transport!.publish([track]);\n    this.localPeer?.auxiliaryTracks.push(track);\n  }\n\n  private async stopEndedScreenshare(onStop: () => void) {\n    HMSLogger.d(this.TAG, `â Screenshare ended natively`);\n    await this.stopScreenShare();\n    onStop();\n  }\n\n  async stopScreenShare() {\n    HMSLogger.d(this.TAG, `â Screenshare ended from app`);\n    const track = this.localPeer?.auxiliaryTracks.find((t) => t.type === HMSTrackType.VIDEO && t.source === 'screen');\n    if (track) {\n      await track.setEnabled(false);\n      this.transport!.unpublish([track]);\n      this.localPeer!.auxiliaryTracks.splice(this.localPeer!.auxiliaryTracks.indexOf(track), 1);\n    }\n  }\n\n  addAudioListener(audioListener: HMSAudioListener) {\n    this.audioListener = audioListener;\n  }\n\n  private onNotificationHandled(method: HMSNotificationMethod, notification: HMSNotifications) {\n    // HMSLogger.d(this.TAG, 'onNotificationHandled', method);\n    switch (method) {\n      case HMSNotificationMethod.PEER_JOIN: {\n        const peer = notification as PeerNotification;\n        const hmsPeer = this.notificationManager.findPeerByPeerId(peer.peerId);\n        hmsPeer\n          ? this.listener!.onPeerUpdate(HMSPeerUpdate.PEER_JOINED, hmsPeer)\n          : HMSLogger.e(this.TAG, `â ï¸ peer not found in peer-list`, peer, this.notificationManager.hmsPeerList);\n        break;\n      }\n\n      case HMSNotificationMethod.PEER_LEAVE: {\n        const peer = notification as PeerNotification;\n        const hmsPeer = new Peer({\n          peerId: peer.peerId,\n          name: peer.info.name,\n          isLocal: false,\n          customerDescription: peer.info.data,\n        }); //@TODO: There should be a cleaner way\n\n        if (hmsPeer.audioTrack) {\n          this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, hmsPeer.audioTrack, hmsPeer);\n        }\n\n        if (hmsPeer.videoTrack) {\n          this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, hmsPeer.videoTrack, hmsPeer);\n        }\n\n        hmsPeer.auxiliaryTracks?.forEach((track) => {\n          this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);\n        });\n\n        this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_LEFT, hmsPeer);\n        break;\n      }\n\n      case HMSNotificationMethod.ROLE_CHANGE:\n        break;\n\n      case HMSNotificationMethod.ACTIVE_SPEAKERS:\n        break;\n\n      case HMSNotificationMethod.BROADCAST:\n        const message = notification as Message;\n        HMSLogger.d(this.TAG, `Received Message:: `, message);\n        this.listener?.onMessageReceived(message);\n        break;\n    }\n  }\n\n  private publish(settings: InitialSettings) {\n    const { isAudioMuted, isVideoMuted, audioInputDeviceId, videoDeviceId } = settings;\n    const { audio, video, allowed } = this.publishParams;\n    const canPublishAudio = allowed && allowed.includes('audio');\n    const canPublishVideo = allowed && allowed.includes('video');\n    HMSLogger.d(this.TAG, `Device IDs :  ${audioInputDeviceId} ,  ${videoDeviceId} `);\n    const audioSettings: HMSAudioTrackSettings = new HMSAudioTrackSettingsBuilder()\n      .codec(audio.codec)\n      .maxBitrate(audio.bitRate)\n      .deviceId(audioInputDeviceId)\n      .build();\n    const videoSettings: HMSVideoTrackSettings = new HMSVideoTrackSettingsBuilder()\n      .codec(video.codec)\n      .maxBitrate(video.bitRate)\n      .maxFramerate(video.frameRate)\n      .setWidth(video.width)\n      .setHeight(video.height)\n      .deviceId(videoDeviceId)\n      .build();\n\n    if (canPublishAudio || canPublishVideo) {\n      this.transport\n        ?.getLocalTracks(\n          new HMSTrackSettingsBuilder()\n            .video(canPublishVideo ? videoSettings : null)\n            .audio(canPublishAudio ? audioSettings : null)\n            .build(),\n        )\n        .then(async (hmsTracks) => {\n          hmsTracks.forEach(async (hmsTrack) => {\n            switch (hmsTrack.type) {\n              case HMSTrackType.AUDIO:\n                this.localPeer!.audioTrack = hmsTrack;\n                break;\n\n              case HMSTrackType.VIDEO:\n                this.localPeer!.videoTrack = hmsTrack;\n                break;\n            }\n            await this.transport!.publish([hmsTrack]);\n\n            if (isAudioMuted && this.localPeer?.audioTrack) {\n              await this.localPeer.audioTrack.setEnabled(false);\n            }\n            if (isVideoMuted && this.localPeer?.videoTrack) {\n              await this.localPeer.videoTrack.setEnabled(false);\n            }\n            this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, hmsTrack, this.localPeer!);\n          });\n          this.published = true;\n        });\n    }\n  }\n\n  createRoom() {\n    const hmsPeerList = this.getPeers();\n    this.hmsRoom = new HMSRoom(this.localPeer!.peerId, '', hmsPeerList);\n    return this.hmsRoom;\n  }\n}\n","import HMSErrors from '../error/HMSErrors';\nimport { HMSExceptionBuilder } from '../error/HMSException';\n\nexport interface AuthToken {\n  roomId: string;\n  userId: string;\n  role: string;\n}\n\nexport default function decodeJWT(token: string): AuthToken {\n  if (token.length === 0) {\n    throw new HMSExceptionBuilder(HMSErrors.MissingToken).build();\n  }\n\n  const parts = token.split('.');\n  if (parts.length !== 3) {\n    throw new HMSExceptionBuilder(HMSErrors.InvalidTokenFormat).build();\n  }\n\n  const payloadStr = atob(parts[1]);\n  try {\n    const payload = JSON.parse(payloadStr);\n    return {\n      roomId: payload.room_id,\n      userId: payload.user_id,\n      role: payload.role,\n    } as AuthToken;\n  } catch (err) {\n    throw new HMSExceptionBuilder(HMSErrors.TokenMissingRoomId).build();\n  }\n}\n"],"names":["HMSAnalyticsLevel","HMSLogLevel","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","HMSLogger","v","tag","data","log","VERBOSE","d","DEBUG","INFO","w","WARN","e","ERROR","level","valueOf","console","debug","warn","HMSConnectionRole","TAG","HMSConnection","role","signal","Array","addTransceiver","track","init","nativeConnection","createOffer","options","offer","JSON","stringify","createAnswer","answer","setLocalDescription","description","setRemoteDescription","addIceCandidate","candidate","getSenders","removeTrack","sender","setMaxBitrate","maxBitrate","find","s","id","trackId","params","getParameters","encodings","setParameters","close","remoteDescription","HMSSimulcastLayer","HMSPublishConnection","config","observer","transport","Publish","RTCPeerConnection","createDataChannel","protocol","onicecandidate","trickle","_this","oniceconnectionstatechange","onIceConnectionChange","iceConnectionState","initAfterJoin","onnegotiationneeded","_this2","onRenegotiationNeeded","trackUpdate","HMSMediaStream","nativeStream","HMSTrackType","HMSRemoteStream","connection","HIGH","setAudio","enabled","audio","syncWithApiChannel","setVideo","layer","video","streamId","framerate","frameRate","apiChannel","_this$connection$apiC","send","HMSDataChannel","nativeChannel","metadata","onmessage","onMessage","onopen","msgQueue","msg","message","readyState","label","HMSTrack","stream","source","nativeTrack","getMediaTrackSettings","getSettings","setEnabled","HMSAction","HMSAudioTrack","AUDIO","kind","HMSRemoteAudioTrack","HMSVideoTrack","VIDEO","addSink","videoElement","srcObject","MediaStream","removeSink","HMSRemoteVideoTrack","NONE","preferLayer","HMSSubscribeConnection","Subscribe","Map","initNativeConnectionCallbacks","ondatachannel","channel","_apiChannel","onApiChannelMessage","ontrack","streams","remoteStreams","has","remote","set","onremovetrack","toRemoveTrackIdx","tracks","findIndex","onTrackRemove","splice","get","onTrackAdd","InitService","fetchInitConfig","token","initEndpoint","region","url","fetch","response","json","HMSVideoCodec","HMSAudioCodec","HMSErrors","GenericConnect","code","messageTemplate","requiresAction","requiresErrorInfo","MissingToken","InvalidTokenFormat","TokenMissingRoomId","NetworkUnavailable","TokenNotAuthorised","InvalidEndpointUrl","EndpointUnreachable","ConnectionLost","GenericStream","NothingToReturn","CodecChangeNotPermitted","PublishSettingsCantBeChanged","CantAccessCaptureDevice","DeviceNotAvailable","DeviceInUse","GenericJoin","UnkownRoom","AlreadyJoined","RoomParticipantLimitReached","GenericAction","NotInTheRoom","InvalidServerResponse","PeerConnectionFailed","UnpublishCalledBeforePublish","NotConnected","Signalling","Unknown","NotReady","HMSExceptionBuilder","codeMessage","cm","action","_action","errorInfo","_errorInfo","from","includes","build","hmsErrorEntry","entries","errorEntry","title","replace","HMSException","JsonRpcSignal","uuid","socket","callbacks","parse","notify","open","uri","WebSocket","addEventListener","openHandler","removeEventListener","reason","onFailure","event","onMessageHandler","p","_this3","join","disableVidAutoSub","isJoinCompleted","pendingTrickle","_this4","target","desc","fromEntries","version","broadcast","recordStart","recordEnd","leave","analytics","text","cb","ex","onNotification","onOffer","onTrickle","HMSAudioTrackSettingsBuilder","OPUS","googEchoCancellation","exact","googExperimentalEchoCancellation","autoGainControl","noiseSuppression","googHighpassFilter","googAudioMirroring","volume","_volume","codec","_codec","_maxBitrate","deviceId","_deviceId","advanced","_advanced","HMSAudioTrackSettings","toConstraints","BuildGetMediaError","toLowerCase","getAudioTrack","settings","navigator","mediaDevices","getUserMedia","getAudioTracks","SwitchDevice","getVideoTrack","getVideoTracks","getEmptyVideoTrack","prevTrack","width","height","canvas","assign","document","createElement","getContext","fillRect","emptyTrack","captureStream","generateHasPropertyChanged","newSettings","oldSettings","prop","HMSLocalAudioTrack","replaceTrackWith","withTrack","replaceTrack","setSettings","hasPropertyChanged","applyConstraints","HMSVideoTrackSettingsBuilder","VP8","setWidth","_width","setHeight","_height","maxFramerate","_maxFramerate","HMSVideoTrackSettings","HMSNotificationMethod","HMSMessageType","HMSLocalVideoTrack","replaceTrackWithBlank","HMSLocalStream","setConnection","getLocalScreen","constraints","getDisplayMedia","GetLocalScreen","local","getLocalTracks","transceiver","direction","sendEncodings","setPreferredCodec","_this$connection","addTrack","removeSender","removedSenderCount","toRemoveLocalTrackIdx","indexOf","TransportState","Message","receiver","time","CHAT","getMessageType","Date","Speaker","peerId","audioLevel","SpeakerList","speakerList","speakers","map","speaker","peer_id","track_id","TrackState","mute","stream_id","Peer","userId","user_id","PeerList","peers","peer","HMSRoomUpdate","HMSPeerUpdate","HMSTrackUpdate","HMSTransport","Disconnected","jsep","subscribeConnection","candidates","publishConnection","signalObserver","callback","promise","_context3","newState","handleIceConnectionFailure","Failed","authToken","customData","autoSubscribeVideo","Join","endpoint","rtcConfiguration","publishConnectionObserver","subscribeConnectionObserver","publishTrack","extra","unpublishTrack","Unpublish","publish","unpublish","sendMessage","originalTrackState","trackState","newTrackState","isLocal","customerDescription","NotificationManager","tracksToProcess","processPendingTracks","trackStateEntry","trackStateMap","hmsPeer","hmsPeerList","audioTrack","screenShareTrackIndex","auxiliaryTracks","videoTrack","dispatchEvent","CustomEvent","detail","listener","onTrackUpdate","TRACK_REMOVED","trackEntry","currentTrackStateInfo","_this$trackStateMap$g","trackInfo","getPeerTrackByTrackId","TRACK_MUTED","TRACK_UNMUTED","TRACK_DESCRIPTION_CHANGED","clear","localPeer","peerList","handlePeerJoin","handleNotification","notification","audioListener","PEER_JOIN","PEER_LEAVE","handlePeerLeave","PEER_LIST","handlePeerList","TRACK_METADATA_ADD","handleTrackMetadataAdd","TRACK_UPDATE","handleTrackUpdate","ROLE_CHANGE","handleRoleChange","ACTIVE_SPEAKERS","handleActiveSpeakers","TRACK_ADDED","onAudioLevelUpdate","dominantSpeaker","dominantSpeakerPeer","findPeerByPeerId","onPeerUpdate","BECAME_DOMINANT_SPEAKER","RESIGNED_DOMINANT_SPEAKER","EventTarget","HMSTrackSettingsBuilder","_video","_audio","simulcast","_simulcast","HMSTrackSettings","Room","HMSAudioSinkManager","notificationManager","elementId","audioEl","autoplay","style","display","audioSink","append","getElementById","remove","body","addSilentAudio","handleTrackAdd","handleTrackRemove","cleanUp","silentAudio","src","GetLocalStream","enumerateDevices","deviceGroups","audioinput","audiooutput","videoinput","device","GetLocalDevices","OFF","BROADCAST","UNSUPPORTED","getNotificationMethod","getNotification","onNotificationHandled","handleOnTrackAdd","handleOnTrackRemove","onError","publishParams","audioSinkManager","audioSinkElementId","parts","split","payloadStr","atob","payload","roomId","room_id","decodeJWT","uuidv4","userName","metaData","autoVideoSubscribe","published","onJoin","createRoom","hmsRoom","_this$transport","getLocalPeer","getPeers","remotePeers","x","hmsMessage","startScreenShare","onStop","screen","bitRate","onended","stopEndedScreenshare","stopScreenShare","_this$localPeer5","t","addAudioListener","PEER_JOINED","PEER_LEFT","onMessageReceived","isAudioMuted","isVideoMuted","audioInputDeviceId","videoDeviceId","allowed","canPublishAudio","canPublishVideo","audioSettings","videoSettings","hmsTracks","hmsTrack","_this5","_this5$localPeer","_this5$localPeer2","HMSRoom"],"mappings":"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"}